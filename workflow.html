<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Workflow Automation Tool</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            overscroll-behavior: none;
            display: flex;
            flex-direction: column;
            height: 100vh;
            margin: 0;
            background-color: #f3f4f6; /* Light gray background */
        }
        .main-container {
            display: flex;
            flex-grow: 1;
            overflow: hidden;
        }
        .toolbox {
            width: 240px; /* Slightly wider */
            background-color: #e2e8f0; /* Slate-200 */
            padding: 16px;
            border-right: 1px solid #cbd5e1; /* Slate-300 */
            overflow-y: auto;
            height: calc(100vh - 60px);
        }
        .tool-item {
            background-color: white; border: 1px solid #cbd5e1; border-radius: 8px;
            padding: 10px 12px; margin-bottom: 12px; cursor: grab; text-align: left; /* Align text left */
            font-size: 0.875rem; box-shadow: 0 2px 4px rgba(0,0,0,0.05); user-select: none;
            display: flex; align-items: center; gap: 8px; /* For icon and text */
        }
        .tool-item i { color: #4b5563; } /* Default icon color */
        .tool-item:hover { border-color: #94a3b8; background-color: #f9fafb; }
        .tool-item.media { background-color: #dcfce7; border-color: #86efac; }
        .tool-item.media i { color: #16a34a; }
        .tool-item.text { background-color: #fef9c3; border-color: #fde047; }
        .tool-item.text i { color: #ca8a04; }
        .tool-item.file { background-color: #f3e8ff; border-color: #d8b4fe; }
        .tool-item.file i { color: #7e22ce; }
        .tool-item.textarea-block { background-color: #e0f2fe; border-color: #90cdf4; }
        .tool-item.textarea-block i { color: #0ea5e9; }
        .tool-item.audio-record { background-color: #ffe4e6; border-color: #fda4af; }
        .tool-item.audio-record i { color: #f43f5e; }
        /* New styles for Start and End blocks */
        .tool-item.start-block { background-color: #d1fae5; border-color: #34d399; } /* Green-100 / Green-400 */
        .tool-item.start-block i { color: #059669; } /* Green-600 */
        .tool-item.end-block { background-color: #ffe4e6; border-color: #f87171; } /* Red-100 / Red-400 */
        .tool-item.end-block i { color: #dc2626; } /* Red-600 */
        /* New styles for Title Block */
        .tool-item.title-block { background-color: #f0fef0; border-color: #a7f3d0; } /* Light green */
        .tool-item.title-block i { color: #065f46; } /* Darker green */


        .workflow-canvas-container {
            flex-grow: 1; position: relative; height: calc(100vh - 60px);
        }
        .workflow-canvas {
            position: absolute; top:0; left:0; right:0; bottom:0;
            background-color: #f0f2f5;
            background-image:
                linear-gradient(to right, rgba(0,0,0,0.03) 1px, transparent 1px),
                linear-gradient(to bottom, rgba(0,0,0,0.03) 1px, transparent 1px);
            background-size: 20px 20px;
            overflow: auto; touch-action: none;
        }
        .node {
            position: absolute; background-color: white; border: 1px solid #cbd5e1;
            border-radius: 8px; padding: 12px; min-width: 200px; min-height: 110px; /* Increased min size */
            box-shadow: 0 4px 6px -1px rgba(0,0,0,0.1), 0 2px 4px -2px rgba(0,0,0,0.1);
            cursor: grab; display: flex; flex-direction: column; align-items: center;
            user-select: none; z-index: 10;
        }
        .node.selected { border-color: #3b82f6; box-shadow: 0 0 0 3px rgba(59,130,246,0.4); }
        .node-type-media { background-color: #dcfce7; border-color: #86efac; }
        .node-type-text { background-color: #fef9c3; border-color: #fde047; }
        .node-type-file { background-color: #f3e8ff; border-color: #d8b4fe; }
        .node-type-generic { background-color: #ffffff; border-color: #cbd5e1; }
        .node-type-textarea { background-color: #e0f2fe; border-color: #90cdf4; }
        .node-type-audio-record { background-color: #ffe4e6; border-color: #fda4af; }
        /* New node styles for Start and End blocks */
        .node-type-start {
            background-color: #d1fae5; /* Green-100 */
            border-color: #34d399; /* Green-400 */
            width: 50px; /* Adjusted width */
            height: 50px; /* Adjusted height */
            min-width: 50px; /* Adjusted fixed width */
            min-height: 50px; /* Adjusted fixed height */
            padding: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 0.8rem;
            text-align: center;
            border-radius: 9999px; /* Fully rounded for a pill/oval shape */
            box-shadow: 0 4px 6px -1px rgba(0,0,0,0.1), 0 2px 4px -2px rgba(0,0,0,0.1);
        }
        .node-type-end {
            background-color: #ffe4e6; /* Red-100 */
            border-color: #f87171; /* Red-400 */
            width: 50px; /* Adjusted width */
            height: 50px; /* Adjusted height */
            min-width: 50px; /* Adjusted fixed width */
            min-height: 50px; /* Adjusted fixed height */
            padding: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 0.8rem;
            text-align: center;
            border-radius: 9999px; /* Fully rounded for a pill/oval shape */
            box-shadow: 0 4px 6px -1px rgba(0,0,0,0.1), 0 2px 4px -2px rgba(0,0,0,0.1);
        }
        /* New node style for Title Block */
        .node-type-title-block {
            background-color: transparent; /* Transparent background */
            border: 1px dashed #9ca3af; /* Dashed border for transparency */
            min-width: 150px;
            min-height: 40px;
            padding: 8px;
            box-shadow: none; /* No shadow for transparency */
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.1rem; /* Slightly larger font */
            font-weight: 600;
            color: #334155; /* Darker text for contrast */
            text-align: center;
        }
        /* Hide specific elements for start/end nodes */
        .node-type-start .node-title,
        .node-type-end .node-title,
        .node-type-start .node-description,
        .node-type-end .node-description,
        .node-type-start .settings-icon,
        .node-type-end .settings-icon,
        .node-type-start .node-status-indicator,
        .node-type-end .node-status-indicator,
        .node-type-start .llm-button,
        .node-type-end .llm-button {
            display: none;
        }
        .node-type-start .connector-point.input,
        .node-type-end .connector-point.output {
            display: none; /* Start nodes don't have input, End nodes don't have output */
        }
        .node-type-start .connector-point.output { right: -7px; top: calc(50% - 7px); }
        .node-type-end .connector-point.input { left: -7px; top: calc(50% - 7px); }

        /* Hide specific elements for title blocks */
        .node-type-title-block .node-description,
        .node-type-title-block .settings-icon,
        .node-type-title-block .node-status-indicator,
        .node-type-title-block .llm-button,
        .node-type-title-block .connector-point {
            display: none;
        }
        .node-type-title-block .node-title {
            border: none; /* Remove dashed border from title itself */
            background-color: transparent; /* Ensure title background is transparent */
            padding: 0;
            margin: 0;
        }
        .node-type-title-block .node-title:focus {
            border: 1px dashed #3b82f6; /* Add focus border */
            background-color: rgba(255,255,255,0.7); /* Slight background on focus */
        }


        .node-title, .node-description {
            width: 100%; text-align: center; padding: 4px;
            border: 1px dashed transparent; border-radius: 4px; outline: none;
        }
        .node-title { font-weight: 600; margin-bottom: 4px; min-height: 28px; }
        .node-description { font-size: 0.875rem; color: #4b5563; min-height: 24px; margin-bottom: 6px;}
        .node-title:focus, .node-description:focus {
            border-color: #9ca3af; background-color: #f9fafb;
        }
        .file-select-button {
            background-color: #3b82f6; color: white; font-size: 0.75rem;
            padding: 4px 8px; border-radius: 6px; margin-top: 6px; margin-bottom: 4px;
            cursor: pointer; transition: background-color 0.2s;
        }
        .file-select-button:hover { background-color: #2563eb; }
        .selected-filename {
            font-size: 0.7rem; color: #6b7280; margin-top: 2px;
            word-break: break-all; max-width: 100%;
        }
        .play-icon {
            cursor: pointer; width: 28px; height: 28px; display: none;
            position: absolute; top: 8px; left: 8px; z-index: 12;
            background-color: rgba(255,255,255,0.7); border-radius: 50%; padding: 2px;
            color: #16a34a; /* Green for play */
        }
        .play-icon.playing { color: #ef4444; } /* Red for pause */

        .connector-point {
            position: absolute; width: 12px; height: 12px; background-color: #60a5fa;
            border: 2px solid white; border-radius: 50%; cursor: crosshair; z-index: 11;
        }
        .connector-point:hover { background-color: #2563eb; }
        .connector-point.input { left: -7px; top: calc(50% - 7px); }
        .connector-point.output { right: -7px; top: calc(50% - 7px); }

        #connections-svg {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; z-index: 1;
        }
        .connection-line {
            stroke: #6b7280; stroke-width: 2.5; fill: none;
            pointer-events: stroke; cursor: pointer;
        }
        .connection-line.selected { stroke: #ef4444; stroke-width: 3.5; }
        
        .action-buttons-container {
            position: fixed; bottom: 20px; right: 20px; z-index: 1000;
            display: flex; flex-direction: column; gap: 8px;
        }
        .connection-tools {
            background-color: white; padding: 8px; border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1); display: flex; gap: 6px;
        }
        .connection-tools button {
            background-color: #e5e7eb; padding: 6px 10px; border-radius: 6px;
            font-size: 0.75rem; border: 1px solid #d1d5db;
        }
        .connection-tools button:hover { background-color: #d1d5db; }
        .connection-tools button.active { background-color: #3b82f6; color: white; border-color: #2563eb;}

        .ghost-node {
            position: absolute; border: 2px dashed #3b82f6; border-radius: 8px;
            padding: 12px; min-width: 180px; min-height: 100px;
            background-color: rgba(255,255,255,0.7); display: flex; flex-direction: column;
            align-items: center; justify-content: center; text-align: center;
            font-style: italic; color: #3b82f6; z-index: 1001; pointer-events: none;
        }
        /* Ghost node specific for start/end blocks */
        .ghost-node.node-type-start,
        .ghost-node.node-type-end {
            width: 50px; /* Adjusted width */
            height: 50px; /* Adjusted height */
            min-width: 50px; /* Adjusted fixed width */
            min-height: 50px; /* Adjusted fixed height */
            padding: 0;
            border-radius: 9999px;
            font-size: 0.8rem;
            font-weight: bold;
        }
        .ghost-node.node-type-start .node-description,
        .ghost-node.node-type-end .node-description {
            display: none; /* Hide description for ghost start/end nodes */
        }
        /* Ghost node specific for title block */
        .ghost-node.node-type-title-block {
            min-width: 150px;
            min-height: 40px;
            padding: 8px;
            font-size: 1.1rem;
            font-weight: 600;
        }
        .ghost-node.node-type-title-block .node-description {
            display: none; /* Hide description for ghost title nodes */
        }


        .modal {
            position: fixed; z-index: 2000; left: 0; top: 0; width: 100%; height: 100%;
            overflow: auto; background-color: rgba(0,0,0,0.7);
            display: flex; justify-content: center; align-items: center;
            backdrop-filter: blur(5px); opacity: 0; visibility: hidden;
            transition: opacity 0.3s ease, visibility 0.3s ease;
        }
        .modal.show { opacity: 1; visibility: visible; }
        .modal-content {
            background-color: #fefefe; margin: auto; padding: 20px; border-radius: 12px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3); max-width: 90%; max-height: 90%;
            position: relative; display: flex; flex-direction: column; align-items: center;
        }
        .modal-content video { max-width: 100%; max-height: 70vh; border-radius: 8px; outline: none; }
        .close-button {
            position: absolute; top: 10px; right: 15px; color: #aaa;
            font-size: 28px; font-weight: bold; cursor: pointer; transition: color 0.2s;
        }
        .close-button:hover, .close-button:focus { color: #333; text-decoration: none; }

        .node-settings-menu {
            position: absolute; background-color: white; border: 1px solid #cbd5e1;
            border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            padding: 8px 0; z-index: 1000; min-width: 220px; /* Increased width for new items */
            opacity: 0; visibility: hidden; transform: scale(0.95) translateY(5px);
            transition: opacity 0.2s ease, transform 0.2s ease, visibility 0.2s ease;
            transform-origin: top right;
        }
        .node-settings-menu.show { opacity: 1; visibility: visible; transform: scale(1) translateY(0); }
        .node-settings-menu ul { list-style: none; padding: 0; margin: 0; }
        .node-settings-menu ul li {
            padding: 8px 16px; font-size: 0.875rem; color: #333; cursor: pointer;
            transition: background-color 0.15s ease, color 0.15s ease;
            position: relative; display: flex; justify-content: space-between; align-items: center;
        }
        .node-settings-menu ul li:hover { background-color: #f3f4f6; color: #1a1a1a; }
        .node-settings-menu ul li.has-submenu::after {
            content: '►'; font-size: 0.7em; margin-left: 10px; color: #9ca3af;
        }
        .node-settings-menu .submenu {
            position: absolute; left: 100%; top: -1px; /* Align with parent item */
            background-color: white; border: 1px solid #cbd5e1; border-radius: 0 8px 8px 0; /* Adjust rounding */
            box-shadow: 0 44px 12px rgba(0,0,0,0.15); padding: 8px 0; min-width: 180px;
            opacity: 0; visibility: hidden; transform: translateX(5px);
            transition: opacity 0.2s ease, transform 0.2s ease, visibility 0.2s ease;
        }
        .node-settings-menu ul li.has-submenu:hover > .submenu { /* Direct child selector */
            opacity: 1; visibility: visible; transform: translateX(0);
        }
        .node-settings-menu .submenu li { padding: 8px 16px; font-size: 0.875rem; color: #333; cursor: pointer; }
        .node-settings-menu .submenu li:hover { background-color: #f3f4f6; color: #1a1a1a; }
        .node-settings-menu ul li label { display: flex; align-items: center; cursor: pointer; width: 100%; }
        .node-settings-menu ul li input[type="checkbox"] {
            margin-right: 10px; /* Increased margin */
            width: 16px; height: 16px; border: 1px solid #9ca3af; border-radius: 4px;
            outline: none; cursor: pointer; transition: background-color 0.2s, border-color 0.2s;
            position: relative; flex-shrink: 0; -webkit-appearance: none; -moz-appearance: none; appearance: none;
        }
        .node-settings-menu ul li input[type="checkbox"]:checked { background-color: #3b82f6; border-color: #3b82f6; }
        .node-settings-menu ul li input[type="checkbox"]:checked::before {
            content: ''; position: absolute; top: 2px; left: 5px; width: 4px; height: 8px;
            border: solid white; border-width: 0 2px 2px 0; transform: rotate(45deg);
        }
        .node-settings-menu .separator { height: 1px; background-color: #e5e7eb; margin: 6px 0; }


        .settings-icon {
            position: absolute; top: 8px; right: 8px; width: 24px; height: 24px; /* Slightly larger */
            cursor: pointer; z-index: 12; color: #6b7280; transition: color 0.15s ease, transform 0.15s ease;
            display: flex; align-items: center; justify-content: center;
        }
        .settings-icon:hover { color: #3b82f6; transform: scale(1.1); }

        .node-textarea {
            width: 100%; height: 80px; padding: 8px; border: 1px solid #d1d5db; border-radius: 6px;
            font-size: 0.875rem; resize: vertical; outline: none; margin-top: 8px;
        }
        .node-textarea:focus { border-color: #3b82f6; box-shadow: 0 0 0 2px rgba(59,130,246,0.2); }

        .youtube-url-input {
            width: 100%; padding: 8px; border: 1px solid #d1d5db; border-radius: 6px;
            font-size: 0.875rem; outline: none; margin-top: 8px; text-align: center;
        }
        .youtube-url-input:focus { border-color: #3b82f6; box-shadow: 0 0 0 2px rgba(59,130,246,0.2); }
        .youtube-url-input.invalid { border-color: #ef4444; box-shadow: 0 0 0 2px rgba(239,68,68,0.2); }

        .audio-record-controls { display: flex; gap: 10px; margin-top: 10px; align-items: center; }
        .audio-record-controls button {
            background-color: transparent; color: #3b82f6; border: none;
            padding: 6px; border-radius: 50%; font-size: 1rem; /* For icon size */
            cursor: pointer; transition: color 0.2s, background-color 0.2s;
            width: 36px; height: 36px; display: flex; align-items: center; justify-content: center;
        }
        .audio-record-controls button:hover { background-color: #e0e7ff; }
        .audio-record-controls button:disabled { color: #9ca3af; cursor: not-allowed; background-color: transparent; }
        .audio-record-controls button i { font-size: 1.25rem; /* Adjust icon size */ }
        
        .recording-status { 
            font-size: 0.75rem; color: #4b5563; margin-top: 8px; 
            display: flex; align-items: center; gap: 4px;
        }
        .recording-status.recording { color: #ef4444; font-weight: bold; }
        .recording-status .wave-icon { color: #3b82f6; } /* Wave icon color */

        /* Toast Notification */
        #toastNotification {
            position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%);
            background-color: #333; color: white; padding: 12px 20px; border-radius: 8px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2); font-size: 0.9rem; z-index: 3000;
            opacity: 0; visibility: hidden; transition: opacity 0.3s ease, visibility 0.3s ease, bottom 0.3s ease;
        }
        #toastNotification.show { opacity: 1; visibility: visible; bottom: 30px; }
        
        /* Node Status Icons (Spinner, Alert) */
        .node-status-indicator {
            position: absolute;
            bottom: 6px; /* Position at bottom left */
            left: 8px;
            display: flex;
            align-items: center;
            gap: 4px;
            z-index: 15; /* Above other node content */
        }
        .node-spinner {
            display: none; /* Hidden by default */
            width: 16px; height: 16px;
            border: 2px solid #f3f3f3; /* Light grey */
            border-top: 2px solid #3b82f6; /* Blue */
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        
        .node-alert-icon {
            display: none; /* Hidden by default */
            color: #ef4444; /* Red */
            cursor: pointer;
            font-size: 1rem;
        }
        .node-alert-icon:hover { color: #dc2626; } /* Darker red on hover */

        .node-success-icon {
            display: none; /* Hidden by default */
            color: #22c55e; /* Green */
            font-size: 1rem;
        }

        /* New stop button style */
        .stop-node-btn {
            background-color: #ef4444; /* Red-500 */
            color: white;
            border: none;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.8rem;
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            transition: background-color 0.2s ease-in-out;
            flex-shrink: 0; /* Prevent shrinking */
            margin-left: 4px; /* Add some space next to spinner/alert */
        }
        .stop-node-btn:hover {
            background-color: #dc2626; /* Red-600 */
        }
        .stop-node-btn:disabled {
            background-color: #fca5a5; /* Red-300 */
            cursor: not-allowed;
        }

        /* Code Preview Modal */
        #codePreviewModal .modal-content {
            width: 90%; max-width: 800px;
            background-color: #1e1e1e; /* Dark background for code */
            color: #f8f8f2; /* Light text */
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.5);
            display: flex;
            flex-direction: column;
        }
        #codePreviewModal pre {
            background-color: #2d2d2d;
            color: #f8f8f2;
            padding: 15px;
            border-radius: 6px;
            overflow-x: auto;
            font-family: 'Fira Code', 'Cascadia Code', monospace; /* Monospaced font */
            font-size: 0.9rem;
            flex-grow: 1;
            min-height: 200px;
            max-height: 70vh; /* Limit height */
            white-space: pre-wrap; /* Wrap long lines */
            word-break: break-all; /* Break long words */
        }
        #codePreviewModal .modal-actions {
            display: flex;
            justify-content: flex-end;
            gap: 10px;
            margin-top: 15px;
        }
        #codePreviewModal .modal-actions button {
            background-color: #3b82f6;
            color: white;
            padding: 8px 16px;
            border-radius: 6px;
            font-size: 0.875rem;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        #codePreviewModal .modal-actions button:hover {
            background-color: #2563eb;
        }
        #projectTitleInput {
            background-color: #f0f2f5;
            border: 1px solid #cbd5e1;
            border-radius: 6px;
            padding: 6px 10px;
            font-size: 1rem;
            font-weight: 500;
            color: #334155;
            width: 250px;
            outline: none;
            transition: border-color 0.2s, box-shadow 0.2s;
        }
        #projectTitleInput:focus {
            border-color: #3b82f6;
            box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.2);
        }
        /* Responsive Header and Buttons */
        .header-container { /* Changed from .bg-white to a new class for clarity */
            background-color: #ffffff;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            padding: 0.75rem 1rem; /* Reduced padding */
            display: flex;
            flex-wrap: wrap; /* Allow wrapping */
            align-items: center;
            justify-content: space-between;
            height: auto; /* Allow height to adjust based on content */
            width: 100%;
            gap: 0.5rem; /* Gap between elements */
        }
        .header-buttons button {
            background-color: #6d28d9; /* Distinct Purple-700 */
            color: white;
            padding: 6px 10px; /* Reduced padding */
            border-radius: 6px; /* Slightly less rounded */
            font-weight: 500;
            font-size: 0.75rem; /* Reduced font size */
            transition: background-color 0.2s ease-in-out;
            display: flex;
            align-items: center;
            gap: 6px; /* Reduced gap */
            white-space: nowrap; /* Prevent text wrapping inside buttons */
        }
        .header-buttons button:hover {
            background-color: #5b21b6; /* Darker purple */
        }
        /* Specific colors for Start/Stop buttons */
        #startProcessBtn {
            background-color: #22c55e; /* Green-500 */
        }
        #startProcessBtn:hover {
            background-color: #16a34a; /* Green-600 */
        }
        #stopProcessBtn {
            background-color: #ef4444; /* Red-500 */
        }
        #stopProcessBtn:hover {
            background-color: #dc2626; /* Red-600 */
        }
        #projectTitleInput {
            width: 180px; /* Adjusted width for better responsiveness */
            font-size: 0.9rem; /* Slightly smaller font */
            padding: 5px 8px;
        }

        /* Responsive adjustments for smaller screens */
        @media (max-width: 768px) {
            .header-container {
                flex-direction: column;
                align-items: flex-start;
                padding: 0.5rem;
            }
            .header-container > div {
                width: 100%;
                justify-content: center;
                margin-bottom: 0.5rem;
            }
            .header-container > div:last-child {
                margin-bottom: 0;
            }
            .header-buttons {
                flex-wrap: wrap;
                justify-content: center;
                width: 100%;
                gap: 0.4rem; /* Even smaller gap for very small screens */
            }
            .header-buttons button {
                padding: 4px 8px; /* Even smaller padding */
                font-size: 0.7rem; /* Even smaller font size */
                flex-grow: 1; /* Allow buttons to grow and fill space */
            }
            #projectTitleInput {
                width: 100%; /* Full width on small screens */
                text-align: center;
                margin-top: 0.5rem;
            }
            #userIdDisplay {
                font-size: 0.7rem; /* Smaller font for user ID */
                text-align: center;
                width: 100%;
                margin-top: 0.5rem;
            }
            .user-profile-container {
                top: auto;
                bottom: 45px; /* Position above on small screens */
                left: 50%;
                transform: translateX(-50%);
                transform-origin: bottom center;
            }
        }


        /* New styles for success floating button */
        #successFloatingButton {
            position: fixed;
            bottom: 20px;
            left: 20px;
            background-color: #22c55e; /* Green-500 */
            color: white;
            padding: 10px 15px;
            border-radius: 8px;
            font-weight: 500;
            font-size: 0.875rem;
            box-shadow: 0 4px 12px rgba(34, 197, 94, 0.3);
            cursor: pointer;
            transition: background-color 0.2s ease-in-out, transform 0.2s ease-in-out;
            z-index: 1000;
            display: none; /* Hidden by default */
            align-items: center;
            gap: 8px;
        }
        #successFloatingButton:hover {
            background-color: #16a34a; /* Green-600 */
            transform: translateY(-2px);
        }

        /* New styles for user profile */
        .user-profile-container {
            position: relative;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        #userProfileImage {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            cursor: pointer;
            object-fit: cover;
            border: 2px solid #cbd5e1;
            transition: border-color 0.2s;
        }
        #userProfileImage:hover {
            border-color: #3b82f6;
        }
        .profile-menu {
            position: absolute;
            top: 45px; /* Adjust based on image size */
            right: 0;
            background-color: white;
            border: 1px solid #cbd5e1;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            padding: 8px 0;
            z-index: 1001;
            min-width: 160px;
            opacity: 0;
            visibility: hidden;
            transform: translateY(5px);
            transition: opacity 0.2s ease, transform 0.2s ease, visibility 0.2s ease;
        }
        .profile-menu.show {
            opacity: 1;
            visibility: visible;
            transform: translateY(0);
        }
        .profile-menu ul {
            list-style: none;
            padding: 0;
            margin: 0;
        }
        .profile-menu ul li {
            padding: 8px 16px;
            font-size: 0.875rem;
            color: #333;
            cursor: pointer;
            transition: background-color 0.15s ease;
        }
        .profile-menu ul li:hover {
            background-color: #f3f4f6;
        }
        /* LLM Buttons */
        .llm-button {
            background-color: #6366f1; /* Indigo-500 */
            color: white;
            padding: 6px 10px;
            border-radius: 6px;
            font-size: 0.75rem;
            margin-top: 8px;
            cursor: pointer;
            transition: background-color 0.2s;
            display: flex;
            align-items: center;
            gap: 4px;
            justify-content: center;
            border: none;
        }
        .llm-button:hover {
            background-color: #4f46e5; /* Indigo-600 */
        }
        .llm-button:disabled {
            background-color: #a5b4fc; /* Indigo-300 */
            cursor: not-allowed;
        }

        /* New Saved Projects Button in Toolbox */
        #savedProjectsBtn {
            background-color: #4f46e5; /* Indigo-600 */
            color: white;
            padding: 10px 15px;
            border-radius: 8px;
            font-weight: 600;
            font-size: 0.9rem;
            margin-bottom: 16px;
            cursor: pointer;
            transition: background-color 0.2s ease-in-out;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            width: 100%;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        #savedProjectsBtn:hover {
            background-color: #4338ca; /* Indigo-700 */
        }

        /* Improved Alert Modal Styles */
        #alertModal .modal-content {
            background-color: #ffffff;
            border-radius: 12px;
            box-shadow: 0 10px 25px rgba(0,0,0,0.2);
            max-width: 400px;
            padding: 30px;
            text-align: center;
            animation: fadeInScale 0.3s ease-out forwards;
            position: relative; /* Needed for close button positioning */
        }

        #alertModal .close-button {
            position: absolute;
            top: 15px;
            right: 15px;
            font-size: 24px;
            color: #9ca3af;
            cursor: pointer;
            transition: color 0.2s ease;
        }
        #alertModal .close-button:hover {
            color: #4b5563;
        }

        #alertModal .modal-icon {
            margin: 0 auto 20px;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background-color: #fee2e2; /* Red-100 */
            color: #ef4444; /* Red-500 */
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2rem;
        }

        #alertModalTitle {
            font-size: 1.5rem;
            font-weight: 700;
            color: #1f2937; /* Gray-900 */
            margin-bottom: 10px;
        }

        #alertModalMessage {
            font-size: 0.95rem;
            color: #4b5563; /* Gray-700 */
            line-height: 1.5;
            margin-bottom: 25px;
        }

        #alertModalCloseButton {
            background-color: #ef4444; /* Red-500 */
            color: white;
            padding: 12px 25px;
            border-radius: 8px;
            font-size: 1rem;
            font-weight: 600;
            transition: background-color 0.2s ease, transform 0.1s ease;
            width: 100%;
            border: none;
            cursor: pointer;
        }
        #alertModalCloseButton:hover {
            background-color: #dc2626; /* Red-600 */
            transform: translateY(-1px);
        }

        @keyframes fadeInScale {
            from { opacity: 0; transform: scale(0.9); }
            to { opacity: 1; transform: scale(1); }
        }

        /* Saved Projects Modal Styles */
        #savedProjectsModal .modal-content {
            background-color: #ffffff;
            border-radius: 12px;
            box-shadow: 0 10px 25px rgba(0,0,0,0.2);
            max-width: 600px;
            width: 90%;
            padding: 20px;
            animation: fadeInScale 0.3s ease-out forwards;
            display: flex;
            flex-direction: column;
        }
        #savedProjectsModal h3 {
            font-size: 1.5rem;
            font-weight: 700;
            color: #1f2937;
            margin-bottom: 20px;
            text-align: center;
        }
        #savedProjectsList {
            list-style: none;
            padding: 0;
            margin: 0;
            max-height: 400px;
            overflow-y: auto;
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            background-color: #f9fafb;
        }
        #savedProjectsList li {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 15px;
            border-bottom: 1px solid #e5e7eb;
            font-size: 0.95rem;
            color: #374151;
        }
        #savedProjectsList li:last-child {
            border-bottom: none;
        }
        #savedProjectsList li:hover {
            background-color: #eff6ff;
        }
        #savedProjectsList li .project-info {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            text-align: left;
        }
        #savedProjectsList li .project-title {
            font-weight: 600;
            color: #1f2937;
        }
        #savedProjectsList li .project-date {
            font-size: 0.8rem;
            color: #6b7280;
            margin-top: 2px;
        }
        #savedProjectsList li .project-actions button {
            background-color: #3b82f6;
            color: white;
            padding: 6px 12px;
            border-radius: 6px;
            font-size: 0.8rem;
            margin-left: 8px;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        #savedProjectsList li .project-actions button:hover {
            background-color: #2563eb;
        }
        #savedProjectsList li .project-actions button.delete-btn {
            background-color: #ef4444;
        }
        #savedProjectsList li .project-actions button.delete-btn:hover {
            background-color: #dc2626;
        }
        #savedProjectsList .no-projects {
            padding: 20px;
            text-align: center;
            color: #6b7280;
            font-style: italic;
        }
    </style>
</head>
<body class="bg-slate-100 select-none">

    <div class="header-container">
        <div class="flex items-center gap-4">
            <h1 class="text-xl font-semibold text-slate-700">Workflow Automator</h1>
            <input type="text" id="projectTitleInput" placeholder="Untitled Project" />
        </div>
        <div class="flex items-center gap-4 header-buttons">
            <button id="previewSequenceBtn">
                <i class="fas fa-eye"></i> Preview
            </button>
            <button id="saveCodeBtn">
                <i class="fas fa-code"></i> Save
            </button>
            <button id="downloadImageBtn">
                <i class="fas fa-download"></i> Image
            </button>
            <button id="startProcessBtn">
                <i class="fas fa-play"></i> Start
            </button>
            <button id="stopProcessBtn" disabled>
                <i class="fas fa-stop-circle"></i> Stop
            </button>
            <div class="user-profile-container">
                <img id="userProfileImage" src="https://placehold.co/36x36/aabbcc/ffffff?text=User" alt="User Profile">
                <div id="userProfileMenu" class="profile-menu">
                    <ul>
                        <li><i class="fas fa-user-circle mr-2"></i> Profile</li>
                        <li><i class="fas fa-cog mr-2"></i> Settings</li>
                        <li class="border-t border-gray-200 mt-1 pt-1"><i class="fas fa-sign-out-alt mr-2"></i> Logout</li>
                    </ul>
                </div>
            </div>
            <div class="text-xs text-slate-500" id="userIdDisplay">UserID: Loading...</div>
        </div>
    </div>

    <div class="main-container">
        <div class="toolbox">
            <button id="savedProjectsBtn"><i class="fas fa-folder-open"></i> Saved Projects</button>
            <h2 class="text-lg font-semibold text-slate-600 mb-4">Toolbox</h2>
            <div class="tool-item start-block" data-type="start"><i class="fas fa-play-circle"></i> Start</div>
            <div class="tool-item end-block" data-type="end"><i class="fas fa-stop-circle"></i> End</div>
            <div class="tool-item title-block" data-type="title-block"><i class="fas fa-heading"></i> Title Block</div>
            <div class="tool-item media" data-type="media"><i class="fas fa-photo-video"></i> Media Input</div>
            <div class="tool-item text" data-type="text"><i class="fab fa-youtube"></i> YouTube Process</div>
            <div class="tool-item file" data-type="file"><i class="fas fa-file-alt"></i> File Operation</div>
            <div class="tool-item textarea-block" data-type="textarea"><i class="fas fa-paragraph"></i> Text Area</div>
            <div class="tool-item audio-record" data-type="audio-record"><i class="fas fa-microphone-alt"></i> Record Audio</div>
        </div>

        <div id="workflowCanvasContainer" class="workflow-canvas-container">
            <div id="workflowCanvas" class="workflow-canvas">
                <svg id="connections-svg">
                    <defs>
                        <marker id="arrowhead" markerWidth="10" markerHeight="7" 
                                refX="8" refY="3.5" orient="auto" fill="#6b7280">
                            <polygon points="0 0, 10 3.5, 0 7" />
                        </marker>
                        <marker id="arrowhead-selected" markerWidth="10" markerHeight="7" 
                                refX="8" refY="3.5" orient="auto" fill="#ef4444">
                            <polygon points="0 0, 10 3.5, 0 7" />
                        </marker>
                    </defs>
                </svg>
            </div>
        </div>
    </div>
    
    <div id="actionButtonsContainer" class="action-buttons-container">
        <div id="connectionTools" class="connection-tools hidden">
            <button data-style="solid">Solid</button>
            <button data-style="dashed">Dashed</button>
            <button data-style="arrow">Arrow</button>
            <button data-style="dashed-arrow">Dash Arrow</button>
        </div>
        <button id="deleteSelectedItemBtn" class="bg-red-500 hover:bg-red-600 text-white font-semibold py-2 px-4 rounded-lg shadow-md transition duration-150 ease-in-out hidden">
            <i class="fas fa-trash-alt mr-2"></i>Delete Selected
        </button>
    </div>

    <button id="successFloatingButton" style="display: none;">
        <i class="fas fa-check-circle"></i> Process Complete
    </button>

    <div id="videoModal" class="modal">
        <div class="modal-content">
            <span class="close-button" id="closeModalButton">&times;</span>
            <video id="modalVideo" controls></video>
        </div>
    </div>

    <div id="codePreviewModal" class="modal">
        <div class="modal-content">
            <span class="close-button" id="closeCodePreviewModalButton">&times;</span>
            <h3 class="text-lg font-semibold mb-3 text-white" id="codePreviewTitle">Workflow Code Preview</h3>
            <pre><code id="codeOutput"></code></pre>
            <div class="modal-actions">
                <button id="copyCodeBtn"><i class="fas fa-copy mr-2"></i> Copy to Clipboard</button>
            </div>
        </div>
    </div>

    <div id="toastNotification">Workflow saved!</div>

    <div id="alertModal" class="modal">
        <div class="modal-content">
            <span class="close-button" id="alertModalCloseButtonTop">&times;</span>
            <div class="modal-icon">
                <i class="fas fa-exclamation-triangle"></i>
            </div>
            <h3 id="alertModalTitle">Error</h3>
            <div class="px-7 py-3">
                <p id="alertModalMessage">An error occurred.</p>
            </div>
            <div class="items-center px-4 py-3">
                <button id="alertModalCloseButton">
                    Close
                </button>
            </div>
        </div>
    </div>

    <div id="savedProjectsModal" class="modal">
        <div class="modal-content">
            <span class="close-button" id="closeSavedProjectsModalButton">&times;</span>
            <h3>Saved Projects</h3>
            <ul id="savedProjectsList">
                </ul>
        </div>
    </div>

    <div id="saveFormatModal" class="modal">
        <div class="modal-content">
            <span class="close-button" id="closeSaveFormatModalButton">&times;</span>
            <h3 class="text-lg font-semibold mb-5">Choose Save Format</h3>
            <div class="flex flex-col gap-4 w-full max-w-xs">
                <button id="saveAsJsonBtn" class="bg-blue-500 hover:bg-blue-600 text-white font-semibold py-2 px-4 rounded-lg shadow-md transition duration-150 ease-in-out">
                    <i class="fas fa-file-code mr-2"></i> Save as JSON
                </button>
                <button id="saveAsYamlBtn" class="bg-green-500 hover:bg-green-600 text-white font-semibold py-2 px-4 rounded-lg shadow-md transition duration-150 ease-in-out">
                    <i class="fas fa-file-alt mr-2"></i> Save as YAML
                </button>
                <button id="saveAsXmlBtn" class="bg-purple-500 hover:bg-purple-600 text-white font-semibold py-2 px-4 rounded-lg shadow-md transition duration-150 ease-in-out">
                    <i class="fas fa-file-invoice mr-2"></i> Save as XML
                </button>
            </div>
        </div>
    </div>


    <script type="module">
        // Firebase Imports
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, getDoc, setDoc, onSnapshot, serverTimestamp, setLogLevel, collection, getDocs, deleteDoc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // DOM Elements
        const workflowCanvasContainer = document.getElementById('workflowCanvasContainer');
        const workflowCanvas = document.getElementById('workflowCanvas');
        const connectionsSvg = document.getElementById('connections-svg');
        const deleteSelectedItemBtn = document.getElementById('deleteSelectedItemBtn');
        const connectionToolsContainer = document.getElementById('connectionTools');
        const toolboxItems = document.querySelectorAll('.tool-item');
        const videoModal = document.getElementById('videoModal');
        const modalVideo = document.getElementById('modalVideo');
        const closeModalButton = document.getElementById('closeModalButton');
        const toastNotification = document.getElementById('toastNotification');
        const userIdDisplay = document.getElementById('userIdDisplay');
        const alertModal = document.getElementById('alertModal');
        const alertModalTitle = document.getElementById('alertModalTitle');
        const alertModalMessage = document.getElementById('alertModalMessage');
        const alertModalCloseButton = document.getElementById('alertModalCloseButton');
        const alertModalCloseButtonTop = document.getElementById('alertModalCloseButtonTop'); // New
        const projectTitleInput = document.getElementById('projectTitleInput');
        const previewSequenceBtn = document.getElementById('previewSequenceBtn');
        const saveCodeBtn = document.getElementById('saveCodeBtn');
        const downloadImageBtn = document.getElementById('downloadImageBtn');
        const startProcessBtn = document.getElementById('startProcessBtn');
        const stopProcessBtn = document.getElementById('stopProcessBtn');
        const codePreviewModal = document.getElementById('codePreviewModal');
        const closeCodePreviewModalButton = document.getElementById('closeCodePreviewModalButton');
        const codeOutput = document.getElementById('codeOutput');
        const copyCodeBtn = document.getElementById('copyCodeBtn');
        const successFloatingButton = document.getElementById('successFloatingButton');
        const userProfileImage = document.getElementById('userProfileImage');
        const userProfileMenu = document.getElementById('userProfileMenu');
        const savedProjectsBtn = document.getElementById('savedProjectsBtn'); // New
        const savedProjectsModal = document.getElementById('savedProjectsModal'); // New
        const closeSavedProjectsModalButton = document.getElementById('closeSavedProjectsModalButton'); // New
        const savedProjectsList = document.getElementById('savedProjectsList'); // New
        const saveFormatModal = document.getElementById('saveFormatModal'); // New
        const closeSaveFormatModalButton = document.getElementById('closeSaveFormatModalButton'); // New
        const saveAsJsonBtn = document.getElementById('saveAsJsonBtn'); // New
        const saveAsYamlBtn = document.getElementById('saveAsYamlBtn'); // New
        const saveAsXmlBtn = document.getElementById('saveAsXmlBtn'); // New


        // Firebase Variables
        let app, auth, db, userId;
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : null;

        // Workflow State
        let nodes = [];
        let connections = [];
        let nodeIdCounter = 0;
        let connectionIdCounter = 0;
        let projectTitle = "Untitled Project";
        
        let selectedItem = null; 
        let activeDrag = null;
        let currentlyDrawingLine = null; 
        let contextMenuElement = null;
        let currentAudio = null;
        let activeSettingsMenu = null;

        let mediaRecorder = null;
        let audioChunks = [];
        let currentRecordingNodeId = null;
        let saveTimeout = null;

        // Backend URL
        const backendBaseUrl = "https://192.168.1.252:8443"; // Corrected URL

        // --- Alert Modal Functions ---
        function showAlertModal(title, message) {
            alertModalTitle.textContent = title;
            alertModalMessage.textContent = message;
            alertModal.classList.add('show'); // Use class for smooth transition
        }
        alertModalCloseButton.addEventListener('click', () => {
            alertModal.classList.remove('show');
        });
        alertModalCloseButtonTop.addEventListener('click', () => { // New close button
            alertModal.classList.remove('show');
        });
        alertModal.addEventListener('click', (e) => { // Close when clicking outside content
            if (e.target === alertModal) {
                alertModal.classList.remove('show');
            }
        });


        // --- Firebase Initialization and Auth ---
        async function initializeFirebase() {
            if (!firebaseConfig) {
                console.error("Firebase config is missing. Firestore integration will be disabled.");
                userIdDisplay.textContent = "UserID: Firebase N/A";
                return;
            }
            try {
                app = initializeApp(firebaseConfig);
                auth = getAuth(app);
                db = getFirestore(app);
                setLogLevel('debug');

                onAuthStateChanged(auth, async (user) => {
                    if (user) {
                        userId = user.uid;
                        console.log("User is signed in with UID:", userId);
                        userIdDisplay.textContent = `UserID: ${userId}`;
                        await loadWorkflow();
                    } else {
                        console.log("User is signed out or token is invalid. Attempting to sign in.");
                        userIdDisplay.textContent = "UserID: Authenticating...";
                        try {
                            if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
                                await signInWithCustomToken(auth, __initial_auth_token);
                                console.log("Signed in with custom token.");
                            } else {
                                await signInAnonymously(auth);
                                console.log("Signed in anonymously.");
                            }
                        } catch (error) {
                            console.error("Error during sign-in:", error);
                            userIdDisplay.textContent = "UserID: Auth Error";
                        }
                    }
                });
            } catch (error) {
                console.error("Error initializing Firebase:", error);
                userIdDisplay.textContent = "UserID: Firebase Init Error";
            }
        }


        // --- Toast Notification ---
        function showToast(message, duration = 2000) {
            toastNotification.textContent = message;
            toastNotification.classList.add('show');
            setTimeout(() => {
                toastNotification.classList.remove('show');
            }, duration);
        }

        // --- Firestore Save/Load ---
        async function saveWorkflow() {
            if (!db || !userId) {
                return;
            }
            clearTimeout(saveTimeout);
            saveTimeout = setTimeout(async () => {
                const workflowData = {
                    projectTitle: projectTitle,
                    nodes: nodes.map(node => ({
                        id: node.id,
                        type: node.type,
                        x: node.x,
                        y: node.y,
                        width: node.width,
                        height: node.height,
                        title: node.title,
                        description: node.description,
                        settings: { ...node.settings },
                        selectedFile: node.selectedFile,
                        fileType: node.fileType,
                        recordedAudioFileName: node.recordedAudioBlob ? `${node.id}_recording.webm` : null, 
                        isLoading: node.isLoading || false,
                        hasError: node.hasError || false,
                        errorMessage: node.errorMessage || '',
                    })),
                    connections: connections.map(conn => ({ ...conn })),
                    nodeIdCounter: nodeIdCounter,
                    connectionIdCounter: connectionIdCounter,
                    updatedAt: serverTimestamp()
                };

                try {
                    const workflowDocRef = doc(db, `artifacts/${appId}/users/${userId}/workflows/defaultWorkflow`);
                    await setDoc(workflowDocRef, workflowData);
                    console.log("Workflow saved to Firestore.");
                    showToast("Workflow saved!");
                } catch (error) {
                    console.error("Error saving workflow to Firestore:", error);
                    showToast("Error saving workflow.", 3000);
                }
            }, 1000);
        }

        async function loadWorkflow(workflowId = 'defaultWorkflow') {
            if (!db || !userId) {
                console.warn("Firestore not initialized or user not authenticated. Skipping load.");
                if (nodes.length === 0) {
                    createInitialNodes();
                }
                return;
            }

            const workflowDocRef = doc(db, `artifacts/${appId}/users/${userId}/workflows/${workflowId}`);
            try {
                const docSnap = await getDoc(workflowDocRef);
                if (docSnap.exists()) {
                    const data = docSnap.data();
                    nodes.forEach(n => n.element.remove());
                    connections.forEach(c => {
                        const lineEl = document.getElementById(c.id);
                        if (lineEl) lineEl.remove();
                    });
                    nodes = [];
                    connections = [];

                    projectTitle = data.projectTitle || "Untitled Project";
                    projectTitleInput.value = projectTitle;

                    nodeIdCounter = data.nodeIdCounter || 0;
                    connectionIdCounter = data.connectionIdCounter || 0;

                    data.nodes.forEach(nodeData => {
                        const newNode = createNode(nodeData.x, nodeData.y, nodeData.type, nodeData.title, nodeData.description, nodeData.id, nodeData.settings, true);
                        if (newNode) {
                            if(nodeData.selectedFile && newNode.element.querySelector('.selected-filename')) {
                                newNode.element.querySelector('.selected-filename').textContent = nodeData.selectedFile;
                                newNode.selectedFile = nodeData.selectedFile;
                                newNode.fileType = nodeData.fileType;
                                if (newNode.type === 'media' && newNode.element.querySelector('.play-icon')) {
                                    const playIconElement = newNode.element.querySelector('.play-icon');
                                    playIconElement.style.display = (nodeData.fileType && (nodeData.fileType.startsWith('audio') || nodeData.fileType.startsWith('video'))) ? 'flex' : 'none';
                                }
                            }
                            if(nodeData.recordedAudioFileName && newNode.element.querySelector('.play-record-btn')) {
                                newNode.element.querySelector('.play-record-btn').disabled = false;
                                const statusDisplay = newNode.element.querySelector('.recording-status');
                                if (statusDisplay) statusDisplay.textContent = 'Recorded';
                            }
                            if (nodeData.isLoading) {
                                newNode.isLoading = true;
                                newNode.element.querySelector('.node-spinner').style.display = 'block';
                            }
                            if (nodeData.hasError) {
                                newNode.hasError = true;
                                newNode.errorMessage = nodeData.errorMessage;
                                newNode.element.querySelector('.node-alert-icon').style.display = 'block';
                            }
                        }
                    });
                    data.connections.forEach(connData => {
                        createConnection(connData.from, connData.to, connData.style, connData.id, true);
                    });
                    updateAllConnections();
                    console.log(`Workflow "${workflowId}" loaded from Firestore.`);
                    showToast(`Workflow "${projectTitle}" loaded.`, 1500);
                } else {
                    console.log(`No saved workflow found for ID "${workflowId}". Starting fresh.`);
                    if (workflowId === 'defaultWorkflow') { // Only create initial nodes if it's the default load
                        createInitialNodes();
                    } else {
                        // If trying to load a specific non-existent project, clear canvas
                        nodes.forEach(n => n.element.remove());
                        connections.forEach(c => {
                            const lineEl = document.getElementById(c.id);
                            if (lineEl) lineEl.remove();
                        });
                        nodes = [];
                        connections = [];
                        projectTitle = "Untitled Project";
                        projectTitleInput.value = projectTitle;
                        nodeIdCounter = 0;
                        connectionIdCounter = 0;
                        updateAllConnections();
                        showToast(`Project "${workflowId}" not found. New blank project created.`, 3000);
                    }
                }
            } catch (error) {
                console.error("Error loading workflow from Firestore:", error);
                showToast("Error loading workflow.", 3000);
                createInitialNodes(); 
            }
        }
        
        function createInitialNodes() {
             if (nodes.length > 0) return; 
            const initialNodeX = (workflowCanvas.offsetWidth || workflowCanvasContainer.offsetWidth) / 2 - 25; // Centered for 50px width
            const initialNodeY = (workflowCanvas.offsetHeight || workflowCanvasContainer.offsetHeight) / 2 - 25; // Centered for 50px height
            createNode(initialNodeX, initialNodeY, 'start', 'Start', ''); // Create a 'start' node
            updateAllConnections();
            saveWorkflow(); 
        }


        // --- Node Management ---
        function createNode(x, y, type = 'generic', titleText, descriptionText, existingId = null, existingSettings = null, isLoading = false) {
            const newIdNum = existingId ? parseInt(existingId.split('-')[1]) : ++nodeIdCounter;
            if (!existingId) nodeIdCounter = Math.max(nodeIdCounter, newIdNum);

            const nodeId = existingId || `node-${newIdNum}`;

            if (nodes.some(n => n.id === nodeId) && !isLoading) {
                console.warn(`Node with ID ${nodeId} already exists. Aborting creation.`);
                if (!existingId) nodeIdCounter--; 
                return null;
            }
            
            const nodeElement = document.createElement('div');
            nodeElement.id = nodeId;
            nodeElement.classList.add('node', `node-type-${type}`);
            
            const canvasRect = workflowCanvas.getBoundingClientRect();
            const finalX = isLoading ? x : (x - canvasRect.left + workflowCanvas.scrollLeft);
            const finalY = isLoading ? y : (y - canvasRect.top + workflowCanvas.scrollTop);

            nodeElement.style.left = `${finalX}px`;
            nodeElement.style.top = `${finalY}px`;

            // Specific dimensions for start/end/title nodes
            if (type === 'start' || type === 'end') {
                nodeElement.style.width = '50px'; // Adjusted
                nodeElement.style.height = '50px'; // Adjusted
                nodeElement.style.minWidth = '50px'; // Adjusted
                nodeElement.style.minHeight = '50px'; // Adjusted
                nodeElement.style.padding = '0';
                nodeElement.style.borderRadius = '9999px'; // Fully rounded
                nodeElement.style.display = 'flex';
                nodeElement.style.alignItems = 'center';
                nodeElement.style.justifyContent = 'center';
                nodeElement.style.fontWeight = 'bold';
                nodeElement.style.fontSize = '0.8rem';
                nodeElement.style.textAlign = 'center';
            } else if (type === 'title-block') {
                nodeElement.style.minWidth = '150px';
                nodeElement.style.minHeight = '40px';
                nodeElement.style.padding = '8px';
            }


            // Add status indicators (spinner, alert, and new stop button)
            const statusIndicatorContainer = document.createElement('div');
            statusIndicatorContainer.classList.add('node-status-indicator');
            
            const spinnerElement = document.createElement('div');
            spinnerElement.classList.add('node-spinner');
            statusIndicatorContainer.appendChild(spinnerElement);

            const alertIconElement = document.createElement('i');
            alertIconElement.classList.add('fas', 'fa-exclamation-triangle', 'node-alert-icon');
            alertIconElement.addEventListener('click', (e) => {
                e.stopPropagation();
                const node = nodes.find(n => n.id === nodeId);
                showAlertModal('Block Error', node ? node.errorMessage || 'An unspecified error occurred in this block.' : 'Error details not available.');
            });
            statusIndicatorContainer.appendChild(alertIconElement);

            const successIconElement = document.createElement('i');
            successIconElement.classList.add('fas', 'fa-check-circle', 'node-success-icon');
            statusIndicatorContainer.appendChild(successIconElement);

            // New: Node-specific stop button
            const stopNodeBtn = document.createElement('button');
            stopNodeBtn.classList.add('stop-node-btn', 'hidden'); // Initially hidden
            stopNodeBtn.title = 'Stop Process';
            stopNodeBtn.innerHTML = '<i class="fas fa-stop"></i>';
            statusIndicatorContainer.appendChild(stopNodeBtn);

            nodeElement.appendChild(statusIndicatorContainer);


            const titleElement = document.createElement('div');
            titleElement.classList.add('node-title');
            titleElement.contentEditable = true;
            
            let contentElement;

            if (!titleText) {
                 switch (type) {
                    case 'media': titleElement.innerText = 'Media Input'; break;
                    case 'text': titleElement.innerText = 'YouTube URL'; break;
                    case 'file': titleElement.innerText = 'File Operation'; break;
                    case 'textarea': titleElement.innerText = 'Text Area'; break;
                    case 'audio-record': titleElement.innerText = 'Record Audio'; break;
                    case 'start': titleElement.innerText = 'Start'; break; // New
                    case 'end': titleElement.innerText = 'End'; break; // New
                    case 'title-block': titleElement.innerText = 'New Title'; break; // New
                    default: titleElement.innerText = `Step ${newIdNum}`;
                }
            } else {
                titleElement.innerText = titleText;
            }

            const defaultDescription = type === 'generic' ? 'Description...' : `${type.charAt(0).toUpperCase() + type.slice(1)} related task...`;
            const currentDescription = descriptionText || defaultDescription;

            if (type === 'textarea') {
                contentElement = document.createElement('textarea');
                contentElement.classList.add('node-textarea');
                contentElement.placeholder = 'Enter multi-line text here...';
                contentElement.rows = 4;
                contentElement.value = (descriptionText === defaultDescription && !isLoading) ? '' : currentDescription;
            } else if (type === 'text') { 
                contentElement = document.createElement('input');
                contentElement.type = 'url';
                contentElement.classList.add('youtube-url-input');
                contentElement.placeholder = 'Enter YouTube URL...';
                contentElement.value = (descriptionText === defaultDescription && !isLoading) ? '' : currentDescription;
                
                const validateYouTubeUrl = () => {
                    const youtubeRegex = /^(https?:\/\/)?(www\.)?(youtube\.com|youtu\.be)\/(watch\?v=|embed\/|v\/|)([\w-]{11})(.*)?$/;
                    if (contentElement.value === '' || youtubeRegex.test(contentElement.value)) {
                        contentElement.classList.remove('invalid');
                        return true;
                    } else {
                        contentElement.classList.add('invalid');
                        return false;
                    }
                };
                contentElement.addEventListener('input', validateYouTubeUrl);
                contentElement.addEventListener('blur', validateYouTubeUrl);
            } else if (type === 'audio-record') {
                contentElement = document.createElement('div');
                contentElement.classList.add('audio-record-controls');
                contentElement.innerHTML = `
                    <button class="start-record-btn" title="Start Recording"><i class="fas fa-microphone"></i></button>
                    <button class="stop-record-btn" title="Stop Recording" disabled><i class="fas fa-stop-circle"></i></button>
                    <button class="play-record-btn" title="Play Recording" disabled><i class="fas fa-play-circle"></i></button>
                `;
                const statusDisplay = document.createElement('div');
                statusDisplay.classList.add('recording-status');
                statusDisplay.textContent = 'Ready';
                nodeElement.appendChild(statusDisplay);

                const startBtn = contentElement.querySelector('.start-record-btn');
                const stopBtn = contentElement.querySelector('.stop-record-btn');
                const playBtn = contentElement.querySelector('.play-record-btn');

                // Check for media device support
                if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                    startBtn.disabled = true;
                    stopBtn.disabled = true;
                    playBtn.disabled = true;
                    statusDisplay.textContent = 'Microphone access not available (HTTPS required).';
                    showAlertModal('Microphone Access Restricted', 'Microphone access is not available in this browser context. Please ensure you are running the application over HTTPS.');
                }

                startBtn.addEventListener('click', async () => {
                    if (mediaRecorder && mediaRecorder.state === 'recording') {
                        if (currentRecordingNodeId && currentRecordingNodeId !== nodeId) {
                            const prevNode = nodes.find(n => n.id === currentRecordingNodeId);
                            if (prevNode && prevNode.mediaRecorder) {
                                prevNode.mediaRecorder.stop(); 
                            }
                        } else {
                           mediaRecorder.stop(); 
                        }
                    }

                    try {
                        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                        mediaRecorder = new MediaRecorder(stream);
                        audioChunks = [];
                        const node = nodes.find(n => n.id === nodeId);
                        if(node) node.mediaRecorder = mediaRecorder; 

                        mediaRecorder.ondataavailable = event => { audioChunks.push(event.data); };
                        mediaRecorder.onstop = () => {
                            const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
                            const audioUrl = URL.createObjectURL(audioBlob);
                            if (node) {
                                node.recordedAudioUrl = audioUrl;
                                node.recordedAudioBlob = audioBlob; 
                                playBtn.disabled = false;
                                statusDisplay.innerHTML = 'Recorded';
                                statusDisplay.classList.remove('recording');
                                saveWorkflow(); 
                            }
                            stream.getTracks().forEach(track => track.stop());
                            currentRecordingNodeId = null;
                            startBtn.disabled = false;
                            stopBtn.disabled = true;
                        };

                        mediaRecorder.start();
                        currentRecordingNodeId = nodeId;
                        startBtn.disabled = true;
                        stopBtn.disabled = false;
                        playBtn.disabled = true;
                        statusDisplay.innerHTML = '<i class="fas fa-wave-square wave-icon mr-1"></i> Recording...';
                        statusDisplay.classList.add('recording');
                    } catch (err) {
                        console.error('Error accessing microphone:', err);
                        statusDisplay.textContent = 'Mic Error';
                        startBtn.disabled = false; stopBtn.disabled = true; playBtn.disabled = true;
                        showAlertModal('Microphone Access Error', 'Could not access your microphone. Please check browser permissions.');
                    }
                });
                stopBtn.addEventListener('click', () => {
                    if (mediaRecorder && mediaRecorder.state === 'recording') {
                        mediaRecorder.stop(); 
                    }
                });
                playBtn.addEventListener('click', () => { 
                    const node = nodes.find(n => n.id === nodeId);
                    if (node && node.recordedAudioUrl) {
                        if (currentAudio && currentAudio !== node.audioElement) {
                            currentAudio.pause();
                            const prevNode = nodes.find(n => n.audioElement === currentAudio);
                            if (prevNode) {
                                const prevPlayBtn = prevNode.element.querySelector('.play-record-btn i');
                                if (prevPlayBtn) { prevPlayBtn.classList.remove('fa-pause-circle'); prevPlayBtn.classList.add('fa-play-circle');}
                            }
                        }
                        if (!node.audioElement) {
                            node.audioElement = new Audio(node.recordedAudioUrl);
                            node.audioElement.addEventListener('ended', () => {
                                playBtn.querySelector('i').classList.remove('fa-pause-circle');
                                playBtn.querySelector('i').classList.add('fa-play-circle');
                                currentAudio = null;
                            });
                        }
                        const icon = playBtn.querySelector('i');
                        if (node.audioElement.paused) {
                            node.audioElement.play();
                            icon.classList.remove('fa-play-circle'); icon.classList.add('fa-pause-circle');
                            currentAudio = node.audioElement;
                        } else {
                            node.audioElement.pause();
                            icon.classList.remove('fa-pause-circle'); icon.classList.add('fa-play-circle');
                            currentAudio = null;
                        }
                    }
                });
            } else if (type === 'start' || type === 'end' || type === 'title-block') { // Added title-block here
                // For 'start', 'end', and 'title-block' nodes, the title element itself acts as the main content display.
                // No separate contentElement is needed or appended.
                contentElement = null; // Explicitly null
            } else {
                contentElement = document.createElement('div');
                contentElement.classList.add('node-description');
                contentElement.contentEditable = true;
                contentElement.innerText = currentDescription;
            }
            
            const commonBlurHandler = (element, propertyName) => {
                nodeElement.style.cursor = 'grab';
                const node = nodes.find(n => n.id === nodeId);
                if (node) {
                    const newValue = element.value !== undefined ? element.value : element.innerText;
                    if (node[propertyName] !== newValue) {
                        node[propertyName] = newValue;
                        saveWorkflow();
                    }
                    node.width = nodeElement.offsetWidth;
                    node.height = nodeElement.offsetHeight;
                    updateAllConnections(); 
                }
            };
            const commonFocusHandler = () => { nodeElement.style.cursor = 'text'; deselectAll(); };
            const commonMousedownHandler = (e) => e.stopPropagation();

            // Only add event listeners if the element exists and is editable, and not a start/end/title node
            if (titleElement && (type !== 'start' && type !== 'end' && type !== 'title-block')) {
                titleElement.addEventListener('focus', commonFocusHandler);
                titleElement.addEventListener('blur', () => commonBlurHandler(titleElement, 'title'));
                titleElement.addEventListener('mousedown', commonMousedownHandler);
                titleElement.addEventListener('touchstart', commonMousedownHandler);
            } else if (type === 'title-block') { // Special handling for title-block title
                titleElement.addEventListener('focus', commonFocusHandler);
                titleElement.addEventListener('blur', () => commonBlurHandler(titleElement, 'title'));
                titleElement.addEventListener('mousedown', commonMousedownHandler);
                titleElement.addEventListener('touchstart', commonMousedownHandler);
            }


            if (contentElement && (type !== 'start' && type !== 'end' && type !== 'title-block')) { // Added title-block here
                contentElement.addEventListener('focus', commonFocusHandler);
                contentElement.addEventListener('blur', () => commonBlurHandler(contentElement, 'description'));
                contentElement.addEventListener('mousedown', commonMousedownHandler);
                contentElement.addEventListener('touchstart', commonMousedownHandler);
            }
            
            nodeElement.appendChild(titleElement);
            if (contentElement) { // Only append if it's not null (i.e., not a start/end/title node)
                nodeElement.appendChild(contentElement);
            }

            let fileSelectButton, selectedFilenameDisplay, playIconElement;
            if (type === 'media' || type === 'file') {
                fileSelectButton = document.createElement('button');
                fileSelectButton.classList.add('file-select-button');
                fileSelectButton.innerHTML = `<i class="fas fa-upload mr-1"></i> Select File`;
                nodeElement.appendChild(fileSelectButton);

                selectedFilenameDisplay = document.createElement('div');
                selectedFilenameDisplay.classList.add('selected-filename');
                nodeElement.appendChild(selectedFilenameDisplay);

                if (type === 'media') {
                    playIconElement = document.createElement('div');
                    playIconElement.classList.add('play-icon');
                    playIconElement.innerHTML = `<i class="fas fa-play"></i>`;
                    nodeElement.prepend(playIconElement);

                    playIconElement.addEventListener('click', (e) => { 
                        e.stopPropagation();
                        const node = nodes.find(n => n.id === nodeId);
                        if (node && node.fileUrl) {
                            const fileType = node.fileType;
                            const icon = playIconElement.querySelector('i');
                            if (fileType.startsWith('audio')) {
                                if (currentAudio && currentAudio !== node.audioElement) {
                                    currentAudio.pause();
                                    const prevPlayIconNode = nodes.find(n => n.audioElement === currentAudio);
                                    if (prevPlayIconNode) {
                                        const prevPlayIcon = prevPlayIconNode.element.querySelector('.play-icon');
                                        if (prevPlayIcon) {
                                            prevPlayIcon.classList.remove('playing');
                                            prevPlayIcon.querySelector('i').classList.remove('fa-pause');
                                            prevPlayIcon.querySelector('i').classList.add('fa-play');
                                        }
                                    }
                                }
                                if (!node.audioElement) {
                                    node.audioElement = new Audio(node.fileUrl);
                                    node.audioElement.addEventListener('ended', () => {
                                        playIconElement.classList.remove('playing');
                                        icon.classList.remove('fa-pause'); icon.classList.add('fa-play');
                                        currentAudio = null;
                                    });
                                }
                                if (node.audioElement.paused) {
                                    node.audioElement.play();
                                    playIconElement.classList.add('playing');
                                    icon.classList.remove('fa-play'); icon.classList.add('fa-pause');
                                    currentAudio = node.audioElement;
                                } else {
                                    node.audioElement.pause();
                                    playIconElement.classList.remove('playing');
                                    icon.classList.remove('fa-pause'); icon.classList.add('fa-play');
                                    currentAudio = null;
                                }
                            } else if (fileType.startsWith('video')) {
                                openVideoModal(node.fileUrl);
                            }
                        }
                    });
                }

                fileSelectButton.addEventListener('click', (e) => { 
                    e.stopPropagation();
                    const fileInput = document.createElement('input');
                    fileInput.type = 'file';
                    if (type === 'media') fileInput.accept = 'image/*,video/*,audio/*';
                    if (type === 'file') fileInput.accept = '.pdf,.json,.csv,.txt,.md';
                    
                    fileInput.onchange = (event) => {
                        const file = event.target.files[0];
                        if (file) {
                            selectedFilenameDisplay.textContent = file.name;
                            const node = nodes.find(n => n.id === nodeId);
                            if (node) {
                                node.selectedFile = file.name;
                                node.fileType = file.type;
                                if (node.fileUrl) URL.revokeObjectURL(node.fileUrl); 
                                node.fileUrl = URL.createObjectURL(file); 

                                if (type === 'media' && playIconElement) {
                                    playIconElement.style.display = (file.type.startsWith('audio') || file.type.startsWith('video')) ? 'flex' : 'none';
                                    if (node.audioElement) {
                                        node.audioElement.pause(); node.audioElement = null;
                                        playIconElement.classList.remove('playing');
                                        playIconElement.querySelector('i').classList.remove('fa-pause');
                                        playIconElement.querySelector('i').classList.add('fa-play');
                                    }
                                }
                                saveWorkflow(); 
                            }
                        }
                    };
                    fileInput.click();
                });
            }

            // LLM Buttons (only for specific node types)
            if (type === 'textarea') {
                const summarizeButton = document.createElement('button');
                summarizeButton.classList.add('llm-button', 'llm-summarize-btn');
                summarizeButton.innerHTML = '<i class="fas fa-magic mr-1"></i> ✨ Summarize Text';
                nodeElement.appendChild(summarizeButton);
                summarizeButton.addEventListener('click', async (e) => {
                    e.stopPropagation();
                    const node = nodes.find(n => n.id === nodeId);
                    if (node && node.description.trim()) {
                        await callGeminiAPI(nodeId, 'description', `Summarize the following text:\n\n"${node.description}"`);
                    } else {
                        showToast("Text area is empty. Nothing to summarize.", 2500);
                    }
                });
            } else if (type === 'generic' || type === 'file') {
                const generateDescriptionButton = document.createElement('button');
                generateDescriptionButton.classList.add('llm-button', 'llm-generate-desc-btn');
                generateDescriptionButton.innerHTML = '<i class="fas fa-magic mr-1"></i> ✨ Generate Description';
                nodeElement.appendChild(generateDescriptionButton);
                generateDescriptionButton.addEventListener('click', async (e) => {
                    e.stopPropagation();
                    const node = nodes.find(n => n.id === nodeId);
                    let prompt = `Generate a concise description for a workflow automation block titled "${node.title}".`;
                    if (node.type === 'file' && node.selectedFile) {
                        prompt += ` The block is related to a file named "${node.selectedFile}" of type "${node.fileType}".`;
                    }
                    await callGeminiAPI(nodeId, 'description', prompt);
                });
            }


            const settingsIcon = document.createElement('div');
            settingsIcon.classList.add('settings-icon');
            settingsIcon.innerHTML = `<i class="fas fa-ellipsis-v"></i>`; 
            nodeElement.appendChild(settingsIcon);
            settingsIcon.addEventListener('click', (e) => {
                e.stopPropagation();
                toggleSettingsMenu(nodeId, e.clientX, e.clientY);
            });

            const inputPoint = document.createElement('div');
            inputPoint.classList.add('connector-point', 'input');
            inputPoint.dataset.nodeId = nodeId; inputPoint.dataset.type = 'input';

            const outputPoint = document.createElement('div');
            outputPoint.classList.add('connector-point', 'output');
            outputPoint.dataset.nodeId = nodeId; outputPoint.dataset.type = 'output';
            
            nodeElement.appendChild(inputPoint);
            nodeElement.appendChild(outputPoint);
            workflowCanvas.appendChild(nodeElement);

            const nodeData = { 
                id: nodeId, element: nodeElement, title: titleElement.innerText,
                description: contentElement ? (contentElement.value !== undefined ? contentElement.value : contentElement.innerText) : '', // Handle null contentElement
                type: type,
                x: finalX, y: finalY,
                width: nodeElement.offsetWidth, height: nodeElement.offsetHeight,
                settings: existingSettings || {}, 
                selectedFile: null, fileType: null, fileUrl: null, audioElement: null,
                mediaRecorder: null, recordedAudioUrl: null, recordedAudioBlob: null,
                isLoading: false,
                hasError: false,
                errorMessage: '',
                abortController: null,
                fetchContent: async function(validateOnly = false) {
                    this.isLoading = false;
                    this.hasError = false;
                    this.errorMessage = '';
                    spinnerElement.style.display = 'none';
                    alertIconElement.style.display = 'none';
                    successIconElement.style.display = 'none'; // Hide success on new attempt
                    if (stopNodeBtn) stopNodeBtn.classList.add('hidden');
                    
                    const llmButton = this.element.querySelector('.llm-button');
                    if (llmButton) llmButton.disabled = false;

                    console.log(`Attempting to process content for node ${this.id} (Type: ${this.type})`);

                    // --- Validation Logic ---
                    let isValid = true;
                    let validationMessage = '';
                    let requestBody = {};
                    let requestUrl = '';
                    let requestHeaders = {};
                    let isFormData = false;

                    switch(this.type) {
                        case 'start':
                        case 'end':
                        case 'title-block':
                            // These blocks are purely representative and do not send data to the backend.
                            // They are always considered valid for processing flow.
                            successIconElement.style.display = 'block'; // Show success icon immediately
                            showToast(`${this.title} block is for flow control/display only.`, 1500);
                            return true; // Always valid, no backend call needed
                        case 'media':
                            requestUrl = `${backendBaseUrl}/api/v2/workflow/media`;
                            if (!this.selectedFile || !this.fileUrl) {
                                isValid = false;
                                validationMessage = `No file selected for Media node.`;
                            } else {
                                isFormData = true;
                                requestBody = new FormData();
                                // Fetch the file Blob from the URL created earlier
                                const response = await fetch(this.fileUrl);
                                const blob = await response.blob();
                                requestBody.append('file', blob, this.selectedFile);
                                requestBody.append('nodeId', this.id);
                                requestBody.append('nodeTitle', this.title);
                                requestBody.append('nodeDescription', this.description);
                                requestBody.append('nodeType', this.type);
                                requestBody.append('fileType', this.fileType);
                                requestBody.append('settings', JSON.stringify(this.settings)); // Pass settings
                            }
                            break;
                        case 'audio-record':
                            requestUrl = `${backendBaseUrl}/api/v2/workflow/media`;
                            if (!this.recordedAudioBlob) {
                                isValid = false;
                                validationMessage = 'No audio recorded for this node.';
                            } else {
                                isFormData = true;
                                requestBody = new FormData();
                                requestBody.append('file', this.recordedAudioBlob, `${this.id}_recording.webm`);
                                requestBody.append('nodeId', this.id);
                                requestBody.append('nodeTitle', this.title);
                                requestBody.append('nodeDescription', this.description);
                                requestBody.append('nodeType', this.type);
                                requestBody.append('fileType', 'audio/webm');
                                requestBody.append('settings', JSON.stringify(this.settings)); // Pass settings
                            }
                            break;
                        case 'text':
                            requestUrl = `${backendBaseUrl}/api/v2/workflow/text-data`;
                            const youtubeInput = this.element.querySelector('.youtube-url-input');
                            if (youtubeInput && !youtubeInput.value) {
                                isValid = false;
                                validationMessage = 'YouTube URL cannot be empty.';
                                youtubeInput.classList.add('invalid');
                            } else if (youtubeInput && !/^(https?:\/\/)?(www\.)?(youtube\.com|youtu\.be)\/(watch\?v=|embed\/|v\/|)([\w-]{11})(.*)?$/.test(youtubeInput.value)) {
                                isValid = false;
                                validationMessage = 'Invalid YouTube URL format.';
                                youtubeInput.classList.add('invalid');
                            } else if (youtubeInput) {
                                youtubeInput.classList.remove('invalid');
                                requestBody = {
                                    nodeId: this.id,
                                    nodeTitle: this.title,
                                    nodeDescription: this.description,
                                    nodeType: this.type,
                                    youtubeUrl: youtubeInput.value,
                                    settings: this.settings // Pass settings
                                };
                                requestHeaders = { 'Content-Type': 'application/json' };
                            }
                            break;
                        case 'file':
                            requestUrl = `${backendBaseUrl}/api/v2/workflow/text-data`;
                            if (!this.selectedFile) {
                                isValid = false;
                                validationMessage = `No file selected for File Operation node.`;
                            } else {
                                // For simplicity, we'll send just the filename and type.
                                // In a real app, you'd fetch the file content here if needed, or upload it via FormData.
                                requestBody = {
                                    nodeId: this.id,
                                    nodeTitle: this.title,
                                    nodeDescription: this.description,
                                    nodeType: this.type,
                                    fileName: this.selectedFile,
                                    fileType: this.fileType,
                                    settings: this.settings // Pass settings
                                };
                                requestHeaders = { 'Content-Type': 'application/json' };
                            }
                            break;
                        case 'textarea':
                            requestUrl = `${backendBaseUrl}/api/v2/workflow/text-data`;
                            if (!this.description || this.description.trim() === '') {
                                isValid = false;
                                validationMessage = 'Text area cannot be empty.';
                            } else {
                                requestBody = {
                                    nodeId: this.id,
                                    nodeTitle: this.title,
                                    nodeDescription: this.description,
                                    nodeType: this.type,
                                    textContent: this.description,
                                    settings: this.settings // Pass settings
                                };
                                requestHeaders = { 'Content-Type': 'application/json' };
                            }
                            break;
                        case 'generic':
                            requestUrl = `${backendBaseUrl}/api/v2/workflow/text-data`;
                            if (!this.description || this.description.trim() === '' || this.description === 'Description...') {
                                isValid = false;
                                validationMessage = 'Generic block description cannot be empty.';
                            } else {
                                requestBody = {
                                    nodeId: this.id,
                                    nodeTitle: this.title,
                                    nodeDescription: this.description,
                                    nodeType: this.type,
                                    settings: this.settings // Pass settings
                                };
                                requestHeaders = { 'Content-Type': 'application/json' };
                            }
                            break;
                        default:
                            isValid = false;
                            validationMessage = `Unsupported node type: ${this.type}`;
                            break;
                    }

                    if (!isValid) {
                        this.hasError = true;
                        this.errorMessage = validationMessage;
                        alertIconElement.style.display = 'block';
                        if (!validateOnly) {
                            showAlertModal('Validation Error', validationMessage);
                            showToast(`Validation failed for "${this.title}".`, 2500);
                        }
                        saveWorkflow();
                        return false;
                    }

                    if (validateOnly) {
                        return true;
                    }

                    this.isLoading = true;
                    spinnerElement.style.display = 'block';
                    if (stopNodeBtn) stopNodeBtn.classList.remove('hidden');
                    if (llmButton) llmButton.disabled = true;
                    saveWorkflow();

                    this.abortController = new AbortController();
                    const signal = this.abortController.signal;

                    try {
                        console.log(`Sending request for node ${this.id} to ${requestUrl}`);
                        const fetchOptions = {
                            method: 'POST',
                            signal: signal,
                            body: isFormData ? requestBody : JSON.stringify(requestBody),
                            headers: requestHeaders,
                            mode: 'cors' // Ensure CORS mode is used
                        };

                        const response = await fetch(requestUrl, fetchOptions);

                        if (!response.ok) {
                            const errorText = await response.text();
                            throw new Error(`HTTP error! status: ${response.status}, message: ${errorText}`);
                        }

                        const responseData = await response.json();
                        console.log(`Response for node ${this.id}:`, responseData);
                        showToast(`Data for "${this.title}" processed successfully!`, 1500);
                        successIconElement.style.display = 'block'; // Show success icon

                        // --- Expected Backend Response Structure ---
                        // The backend is designed to return a JSON object with at least 'status', 'message', and 'nodeId'.
                        // Depending on the node type and processing, it might include 'processingResults' or 'processedContent'.

                        /*
                         * Expected `responseData` structure:
                         * {
                         * "status": "success" | "error",
                         * "message": "A descriptive message about the processing result.",
                         * "nodeId": "string" // The ID of the node that was processed
                         *
                         * // For 'media' and 'audio-record' nodes:
                         * "filename"?: "string", // Original filename
                         * "fileType"?: "string", // Original file type
                         * "processingResults"?: {
                         * "extractedAudioPath"?: "string", // Path to extracted audio (if video and extractAudio was true)
                         * "speechToText"?: "string",       // Transcribed text (if speech recognition was performed)
                         * // ... other media-specific results
                         * },
                         *
                         * // For 'text', 'file', and 'generic' nodes:
                         * "processedContent"?: {
                         * "youtubeInfo"?: {
                         * "url": "string",
                         * "title": "string",
                         * "duration": "string"
                         * }, // If YouTube URL was processed
                         * "summary"?: "string", // If text content was summarized by AI
                         * "generatedAudioPath"?: "string", // URL to generated audio (if TTS was performed)
                         * "fileInfo"?: {
                         * "name": "string",
                         * "type": "string",
                         * "simulatedContentPreview": "string"
                         * }, // If file operation was processed
                         * // ... other text/file-specific results
                         * }
                         * }
                         */

                        return true;

                    } catch (error) {
                        console.error(`Error processing content for node ${this.id}:`, error);
                        if (error.name === 'AbortError') {
                            this.errorMessage = 'Process aborted.';
                            this.hasError = false; // Not an error, but user stopped
                        } else if (error instanceof TypeError && error.message === 'Failed to fetch') {
                            this.hasError = true;
                            this.errorMessage = `Network error or CORS issue. Please ensure the backend server is running at ${backendBaseUrl} and configured to allow requests from this origin.`;
                            alertIconElement.style.display = 'block';
                            showAlertModal('Network/CORS Error', this.errorMessage);
                        } else {
                            this.hasError = true;
                            this.errorMessage = error.message || "An unknown error occurred during processing.";
                            alertIconElement.style.display = 'block';
                            showAlertModal('Processing Error', this.errorMessage);
                        }
                        showToast(`Error processing "${this.title}".`, 3000);
                        return false;
                    } finally {
                        this.isLoading = false;
                        spinnerElement.style.display = 'none';
                        if (llmButton) llmButton.disabled = false;
                        if (stopNodeBtn) stopNodeBtn.classList.add('hidden');
                        this.abortController = null;
                        saveWorkflow();
                    }
                }
            };
            
            if (existingSettings) {
                nodeData.settings = JSON.parse(JSON.stringify(existingSettings)); 
            }


            if (!nodes.some(n => n.id === nodeId)) {
                 nodes.push(nodeData);
            } else if (isLoading) { 
                const existingNodeIndex = nodes.findIndex(n => n.id === nodeId);
                nodes[existingNodeIndex] = nodeData;
            }


            setupNodeEvents(nodeElement, nodeData);
            // Only add connector points if not a title block
            if (type !== 'title-block') {
                setupConnectorPointEvents(inputPoint, nodeData);
                setupConnectorPointEvents(outputPoint, nodeData);
            } else {
                // Hide connector points for title blocks
                inputPoint.style.display = 'none';
                outputPoint.style.display = 'none';
            }


            stopNodeBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                const node = nodes.find(n => n.id === nodeId);
                if (node && node.abortController) {
                    node.abortController.abort();
                    showToast(`Process for "${node.title}" stopped.`, 1500);
                }
            });
            
            if (!isLoading) {
                selectItem(nodeData);
                saveWorkflow(); 
            }
            return nodeData;
        }

        // --- New Gemini API Call Function ---
        async function callGeminiAPI(nodeId, targetField, promptText) {
            const node = nodes.find(n => n.id === nodeId);
            if (!node) return;

            const spinnerElement = node.element.querySelector('.node-spinner');
            const alertIconElement = node.element.querySelector('.node-alert-icon');
            const successIconElement = node.element.querySelector('.node-success-icon'); // Get success icon
            const llmButton = node.element.querySelector('.llm-button');
            const stopNodeBtn = node.element.querySelector('.stop-node-btn');

            node.isLoading = true;
            node.hasError = false;
            node.errorMessage = '';
            spinnerElement.style.display = 'block';
            alertIconElement.style.display = 'none';
            successIconElement.style.display = 'none'; // Hide success on new attempt
            if (llmButton) llmButton.disabled = true;
            if (stopNodeBtn) stopNodeBtn.classList.remove('hidden');
            saveWorkflow();

            try {
                node.abortController = new AbortController();
                const signal = node.abortController.signal;

                // Simulate Gemini API call
                await new Promise(resolve => {
                    setTimeout(() => {
                        if (signal.aborted) {
                            node.errorMessage = 'Process aborted.';
                            node.hasError = false;
                            resolve();
                            return;
                        }
                        let generatedText = '';
                        if (promptText.includes('Summarize')) {
                            generatedText = `[Simulated Summary]: This text discusses the core concepts of workflow automation, emphasizing efficiency and streamlined processes.`;
                        } else if (promptText.includes('Generate a concise description')) {
                            generatedText = `[Simulated Description]: This block is designed to manage and process data related to a specific workflow step, ensuring smooth transitions between tasks.`;
                        } else {
                            generatedText = `[Simulated AI Response]: Based on your input, here's a generated response.`;
                        }
                        
                        node[targetField] = generatedText;
                        if (node.type === 'textarea') {
                            node.element.querySelector('.node-textarea').value = generatedText;
                        } else if (node.type === 'generic' || node.type === 'file') {
                            node.element.querySelector('.node-description').innerText = generatedText;
                        }
                        showToast(`Content for "${node.title}" updated by Gemini (simulated)!`, 2000);
                        successIconElement.style.display = 'block'; // Show success icon
                        resolve();
                    }, 1500); // Simulate 1.5 seconds latency
                });

            } catch (error) {
                console.error(`Error calling Gemini API for node ${nodeId}:`, error);
                if (error.name === 'AbortError') {
                    console.warn(`Operation for node ${nodeId} was aborted.`);
                    node.errorMessage = 'Process aborted.';
                    node.hasError = false;
                } else {
                    node.hasError = true;
                    node.errorMessage = error.message || "An unknown error occurred during Gemini API call.";
                    alertIconElement.style.display = 'block';
                    showToast(`Error with Gemini for "${node.title}".`, 3000);
                }
            } finally {
                node.isLoading = false;
                spinnerElement.style.display = 'none';
                if (llmButton) llmButton.disabled = false;
                if (stopNodeBtn) stopNodeBtn.classList.add('hidden');
                node.abortController = null;
                saveWorkflow();
            }
        }


        function setupNodeEvents(nodeElement, nodeData) {
            const handleStart = (clientX, clientY, e) => {
                if (e.target.contentEditable === 'true' || 
                    e.target.classList.contains('connector-point') || 
                    e.target.classList.contains('file-select-button') || 
                    e.target.closest('.play-icon') ||
                    e.target.closest('.settings-icon') ||
                    e.target.tagName === 'TEXTAREA' || e.target.tagName === 'INPUT' ||
                    e.target.closest('.audio-record-controls') ||
                    e.target.closest('.node-settings-menu') ||
                    e.target.closest('.llm-button') ||
                    e.target.closest('.stop-node-btn') ||
                    e.target.closest('.node-status-indicator')) {
                    return;
                }
                if (e.type === 'touchstart') e.preventDefault();
                selectItem(nodeData); removeContextMenu(); removeSettingsMenu();
                nodeElement.style.cursor = 'grabbing';
                const nodeRect = nodeElement.getBoundingClientRect();
                activeDrag = {
                    element: nodeElement, data: nodeData,
                    offsetX: clientX - nodeRect.left, offsetY: clientY - nodeRect.top,
                    initialScrollX: workflowCanvas.scrollLeft, initialScrollY: workflowCanvas.scrollTop
                };
                nodeElement.style.zIndex = '100'; 
            };
            nodeElement.addEventListener('mousedown', (e) => handleStart(e.clientX, e.clientY, e));
            nodeElement.addEventListener('touchstart', (e) => {
                if (e.touches.length === 1) handleStart(e.touches[0].clientX, e.touches[0].clientY, e);
            }, { passive: false });
            nodeElement.addEventListener('contextmenu', (e) => {
                e.preventDefault(); selectItem(nodeData); removeSettingsMenu();
                showContextMenu(e.clientX, e.clientY, nodeData);
            });
        }
        
        function setupToolboxEvents() {
            toolboxItems.forEach(item => {
                item.setAttribute('draggable', 'false'); 
                const handleToolStart = (clientX, clientY, e) => {
                    e.preventDefault(); deselectAll(); removeContextMenu(); removeSettingsMenu();
                    const type = item.dataset.type;
                    const ghostNode = document.createElement('div');
                    ghostNode.classList.add('ghost-node', `node-type-${type}`);
                    const ghostTitle = document.createElement('div');
                    ghostTitle.classList.add('node-title');
                     switch (type) {
                        case 'media': ghostTitle.innerText = 'Media Input'; break;
                        case 'text': ghostTitle.innerText = 'YouTube URL'; break;
                        case 'file': ghostTitle.innerText = 'File Operation'; break;
                        case 'textarea': ghostTitle.innerText = 'Text Area'; break;
                        case 'audio-record': ghostTitle.innerText = 'Record Audio'; break;
                        case 'start': ghostTitle.innerText = 'Start'; break; // New
                        case 'end': ghostTitle.innerText = 'End'; break; // New
                        case 'title-block': ghostTitle.innerText = 'New Title'; break; // New
                        default: ghostTitle.innerText = `New ${type}`;
                    }
                    const ghostDesc = document.createElement('div');
                    ghostDesc.classList.add('node-description');
                    ghostDesc.innerText = 'Drag to canvas...';
                    ghostNode.appendChild(ghostTitle);
                    if (type !== 'start' && type !== 'end' && type !== 'title-block') { // Only append description for non-start/end/title nodes
                        ghostNode.appendChild(ghostDesc);
                    }

                    document.body.appendChild(ghostNode);
                    const itemRect = item.getBoundingClientRect();
                    activeDrag = {
                        isNew: true, type: type, ghostElement: ghostNode,
                        offsetX: clientX - itemRect.left, offsetY: clientY - itemRect.top,
                        initialTitle: ghostTitle.innerText,
                        initialDescription: (type === 'start' || type === 'end' || type === 'title-block') ? '' : `${type.charAt(0).toUpperCase() + type.slice(1)} related task...`
                    };
                    ghostNode.style.left = `${clientX - activeDrag.offsetX}px`;
                    ghostNode.style.top = `${clientY - activeDrag.offsetY}px`;
                };
                item.addEventListener('mousedown', (e) => handleToolStart(e.clientX, e.clientY, e));
                item.addEventListener('touchstart', (e) => {
                    if (e.touches.length === 1) handleToolStart(e.touches[0].clientX, e.touches[0].clientY, e);
                }, { passive: false });
            });
        }

        function setupConnectorPointEvents(pointElement, nodeData) {
            // Prevent input connector on 'start' node and output connector on 'end' node
            if ((nodeData.type === 'start' && pointElement.dataset.type === 'input') ||
                (nodeData.type === 'end' && pointElement.dataset.type === 'output') ||
                (nodeData.type === 'title-block')) { // Added title-block here
                pointElement.style.display = 'none'; // Hide the connector point visually
                return; // Do not attach event listeners
            }

            const handleStartConnector = (e) => {
                e.stopPropagation(); deselectAll(); removeContextMenu(); removeSettingsMenu();
                const type = pointElement.dataset.type;
                if (type === 'output') { 
                    const line = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                    line.classList.add('connection-line');
                    const startPos = getConnectorPosition(nodeData, 'output');
                    line.setAttribute('d', `M ${startPos.x} ${startPos.y} L ${startPos.x} ${startPos.y}`);
                    connectionsSvg.appendChild(line);
                    currentlyDrawingLine = {
                        startNodeId: nodeData.id, startPortType: 'output', lineElement: line, style: 'solid'
                    };
                }
            };
            const handleEndConnector = (e) => {
                e.stopPropagation();
                const tempLineInfo = currentlyDrawingLine; 
                if (tempLineInfo && pointElement.dataset.type === 'input' && tempLineInfo.startNodeId !== nodeData.id) {
                    createConnection(tempLineInfo.startNodeId, nodeData.id, tempLineInfo.style); 
                    if (tempLineInfo.lineElement && connectionsSvg.contains(tempLineInfo.lineElement)) { 
                       connectionsSvg.removeChild(tempLineInfo.lineElement);
                    }
                } else if (tempLineInfo && tempLineInfo.lineElement && connectionsSvg.contains(tempLineInfo.lineElement)) {
                    connectionsSvg.removeChild(tempLineInfo.lineElement);
                }
                currentlyDrawingLine = null; 
            };
            if (pointElement.dataset.type === 'output') {
                pointElement.addEventListener('mousedown', handleStartConnector);
                pointElement.addEventListener('touchstart', (e) => {
                    e.stopPropagation(); if (e.touches.length === 1) handleStartConnector(e);
                }, { passive: false });
            }
            if (pointElement.dataset.type === 'input') {
                 pointElement.addEventListener('mouseup', handleEndConnector);
                 pointElement.addEventListener('touchend', (e) => { e.stopPropagation(); handleEndConnector(e); });
            }
        }

        function deleteNode(nodeId) {
            const nodeIndex = nodes.findIndex(n => n.id === nodeId);
            if (nodeIndex > -1) {
                const node = nodes[nodeIndex];
                if (node.audioElement && !node.audioElement.paused) {
                    node.audioElement.pause();
                    if (currentAudio === node.audioElement) currentAudio = null;
                }
                if (node.mediaRecorder && node.mediaRecorder.state === 'recording') {
                    node.mediaRecorder.stop(); 
                }
                if (node.fileUrl) URL.revokeObjectURL(node.fileUrl);
                if (node.recordedAudioUrl) URL.revokeObjectURL(node.recordedAudioUrl);
                if (node.abortController) node.abortController.abort();

                if (node.element.parentElement) node.element.parentElement.removeChild(node.element);
                nodes.splice(nodeIndex, 1);
                disconnectAllLinesFromNode(nodeId, true);
                if (selectedItem && selectedItem.id === nodeId) deselectAll();
                removeContextMenu(); removeSettingsMenu(); updateAllConnections();
                saveWorkflow();
            }
        }
        
        function disconnectAllLinesFromNode(nodeId, isCascadingDelete = false) {
            connections = connections.filter(c => {
                if (c.from === nodeId || c.to === nodeId) {
                    deleteConnection(c.id, false, isCascadingDelete);
                    return false;
                }
                return true;
            });
            updateAllConnections();
            if (!isCascadingDelete) {
                saveWorkflow();
            }
        }


        // --- Connection Management ---
        function createConnection(fromNodeId, toNodeId, style = 'solid', existingId = null, isLoading = false) {
            // Prevent connection from an 'end' node or to a 'start' node or to/from a 'title-block'
            const fromNode = nodes.find(n => n.id === fromNodeId);
            const toNode = nodes.find(n => n.id === toNodeId);

            if (!fromNode || !toNode) {
                console.warn("Attempted to create connection with non-existent nodes.");
                return null;
            }
            if (fromNode.type === 'end' || toNode.type === 'start' || fromNode.type === 'title-block' || toNode.type === 'title-block') {
                showToast("Cannot connect from 'End' node, to 'Start' node, or to/from 'Title' blocks.", 3000);
                const tempLine = currentlyDrawingLine ? currentlyDrawingLine.lineElement : null;
                if (tempLine && connectionsSvg.contains(tempLine)) connectionsSvg.removeChild(tempLine);
                currentlyDrawingLine = null;
                return null;
            }

            if (fromNodeId === toNodeId || connections.some(c => c.from === fromNodeId && c.to === toNodeId)) {
                const tempLine = currentlyDrawingLine ? currentlyDrawingLine.lineElement : null;
                if (tempLine && connectionsSvg.contains(tempLine)) connectionsSvg.removeChild(tempLine);
                currentlyDrawingLine = null; return null;
            }

            const newIdNum = existingId ? parseInt(existingId.split('-')[1]) : ++connectionIdCounter;
            if(!existingId) connectionIdCounter = Math.max(connectionIdCounter, newIdNum);
            const connectionId = existingId || `conn-${newIdNum}`;

            if (connections.some(c => c.id === connectionId) && !isLoading) {
                console.warn(`Connection with ID ${connectionId} already exists.`);
                if(!existingId) connectionIdCounter--;
                return null;
            }

            const connection = { id: connectionId, from: fromNodeId, to: toNodeId, style: style };
            
            if (!connections.some(c => c.id === connectionId)) {
                connections.push(connection);
            } else if (isLoading) {
                const existingConnIndex = connections.findIndex(c => c.id === connectionId);
                connections[existingConnIndex] = connection;
            }

            drawConnection(connection);
            currentlyDrawingLine = null;
            if (!isLoading) saveWorkflow();
            return connection;
        }

        function drawConnection(connection) { 
            const fromNode = nodes.find(n => n.id === connection.from);
            const toNode = nodes.find(n => n.id === connection.to);
            if (!fromNode || !toNode) return;

            let line = document.getElementById(connection.id);
            if (!line) {
                line = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                line.id = connection.id;
                line.classList.add('connection-line');
                connectionsSvg.appendChild(line);
                line.addEventListener('mousedown', (e) => {
                    e.stopPropagation(); selectItem(connection); removeContextMenu(); removeSettingsMenu();
                });
                line.addEventListener('touchstart', (e) => {
                    e.stopPropagation(); selectItem(connection); removeContextMenu(); removeSettingsMenu();
                }, { passive: true });
            }
            const startPos = getConnectorPosition(fromNode, 'output');
            const endPos = getConnectorPosition(toNode, 'input');
            const dx = Math.abs(startPos.x - endPos.x);
            const cp1x = startPos.x + dx * 0.6; const cp1y = startPos.y;
            const cp2x = endPos.x - dx * 0.6;   const cp2y = endPos.y;
            line.setAttribute('d', `M ${startPos.x} ${startPos.y} C ${cp1x} ${cp1y}, ${cp2x} ${cp2y}, ${endPos.x} ${endPos.y}`);
            
            line.removeAttribute('stroke-dasharray');
            line.removeAttribute('marker-end');
            const isSelected = selectedItem && selectedItem.id === connection.id;

            if (connection.style === 'dashed' || connection.style === 'dashed-arrow') {
                line.setAttribute('stroke-dasharray', '5,5');
            }
            if (connection.style === 'arrow' || connection.style === 'dashed-arrow') {
                line.setAttribute('marker-end', `url(#${isSelected ? 'arrowhead-selected' : 'arrowhead'})`);
            }
        }
        
        function getConnectorPosition(node, type) { 
            if (node.element) { 
                 node.width = node.element.offsetWidth; 
                 node.height = node.element.offsetHeight;
            }
            const x = type === 'output' ? node.x + node.width : node.x;
            const y = node.y + node.height / 2;
            return { x, y };
        }

        function updateAllConnections() { 
            connectionsSvg.style.width = `${Math.max(workflowCanvas.scrollWidth, workflowCanvas.clientWidth)}px`;
            connectionsSvg.style.height = `${Math.max(workflowCanvas.scrollHeight, workflowCanvas.clientHeight)}px`;
            if (!document.getElementById('arrowhead')) {
                const defs = connectionsSvg.querySelector('defs') || document.createElementNS('http://www.w3.org/2000/svg', 'defs');
                if (!connectionsSvg.contains(defs)) connectionsSvg.prepend(defs);
                defs.innerHTML = `
                    <marker id="arrowhead" markerWidth="10" markerHeight="7" refX="8" refY="3.5" orient="auto" fill="#6b7280"><polygon points="0 0, 10 3.5, 0 7" /></marker>
                    <marker id="arrowhead-selected" markerWidth="10" markerHeight="7" refX="8" refY="3.5" orient="auto" fill="#ef4444"><polygon points="0 0, 10 3.5, 0 7" /></marker>
                `;
            }
            connections.forEach(conn => drawConnection(conn));
        }

        function deleteConnection(connectionId, shouldSelect = true, isCascading = false) {
            const connIndex = connections.findIndex(c => c.id === connectionId);
            if (connIndex > -1) {
                const lineElement = document.getElementById(connectionId);
                if (lineElement && lineElement.parentElement) connectionsSvg.removeChild(lineElement);
                connections.splice(connIndex, 1);
                if (shouldSelect && selectedItem && selectedItem.id === connectionId) deselectAll();
                if (!isCascading) { 
                    removeContextMenu(); removeSettingsMenu();
                    saveWorkflow();
                }
            }
        }

        // --- Selection & UI Management ---
        function selectItem(item) { 
            deselectAll(); 
            selectedItem = item;
            deleteSelectedItemBtn.classList.remove('hidden');

            if (item.element) { 
                item.element.classList.add('selected');
                connectionToolsContainer.classList.add('hidden');
            } else { 
                const lineElement = document.getElementById(item.id);
                if (lineElement) lineElement.classList.add('selected');
                connectionToolsContainer.classList.remove('hidden');
                updateConnectionToolButtons(item.style);
                drawConnection(item); 
            }
        }

        function deselectAll() { 
             if (selectedItem) {
                if (selectedItem.element) { 
                    selectedItem.element.classList.remove('selected');
                } else { 
                    const lineElement = document.getElementById(selectedItem.id);
                    if (lineElement) {
                        lineElement.classList.remove('selected');
                        const conn = connections.find(c => c.id === selectedItem.id);
                        if(conn) drawConnection(conn); 
                    }
                }
            }
            selectedItem = null;
            deleteSelectedItemBtn.classList.add('hidden');
            connectionToolsContainer.classList.add('hidden');
        }

        function updateConnectionToolButtons(activeStyle) { 
            connectionToolsContainer.querySelectorAll('button').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.style === activeStyle);
            });
        }
        
        connectionToolsContainer.querySelectorAll('button').forEach(button => {
            button.addEventListener('click', () => { 
                if (selectedItem && !selectedItem.element) { 
                    selectedItem.style = button.dataset.style;
                    drawConnection(selectedItem);
                    updateConnectionToolButtons(selectedItem.style);
                    saveWorkflow();
                }
            });
        });


        function showContextMenu(x, y, nodeData) { 
            // Do not show context menu for start/end/title nodes
            if (nodeData.type === 'start' || nodeData.type === 'end' || nodeData.type === 'title-block') {
                return;
            }

            removeContextMenu(); removeSettingsMenu();
            const menu = document.createElement('div');
            menu.id = 'nodeContextMenu';
            menu.className = 'absolute bg-white shadow-xl rounded-md py-1 z-50 border border-gray-200';
            const canvasRect = workflowCanvasContainer.getBoundingClientRect();
            const menuWidth = 150; 
            const menuHeight = 70; 
            menu.style.left = `${Math.min(x, canvasRect.right - menuWidth - 5)}px`; 
            menu.style.top = `${Math.min(y, canvasRect.bottom - menuHeight - 5)}px`;

            const renameOption = document.createElement('div');
            renameOption.className = 'px-4 py-2 text-sm text-gray-700 hover:bg-blue-500 hover:text-white cursor-pointer rounded-t-md transition-colors duration-150';
            renameOption.innerHTML = `<i class="fas fa-pencil-alt w-4 mr-2"></i> Rename Title`;
            renameOption.onclick = () => { 
                const textElement = nodeData.element.querySelector('.node-title');
                if (textElement) {
                    textElement.focus();
                    const range = document.createRange(); range.selectNodeContents(textElement);
                    const sel = window.getSelection(); sel.removeAllRanges(); sel.addRange(range);
                }
                removeContextMenu();
            };
            const deleteOption = document.createElement('div');
            deleteOption.className = 'px-4 py-2 text-sm text-red-600 hover:bg-red-500 hover:text-white cursor-pointer rounded-b-md transition-colors duration-150';
            deleteOption.innerHTML = `<i class="fas fa-trash-alt w-4 mr-2"></i> Delete Node`;
            deleteOption.onclick = () => { deleteNode(nodeData.id); removeContextMenu(); }; 
            menu.appendChild(renameOption); menu.appendChild(deleteOption);
            document.body.appendChild(menu); contextMenuElement = menu; 
        }
        function removeContextMenu() { 
            if (contextMenuElement) { contextMenuElement.remove(); contextMenuElement = null; }
        }

        // --- Node Settings Menu ---
        function toggleSettingsMenu(nodeId, clientX, clientY) {
            const node = nodes.find(n => n.id === nodeId);
            if (!node) return;

            // Do not show settings menu for start/end/title nodes
            if (node.type === 'start' || node.type === 'end' || node.type === 'title-block') {
                return;
            }

            if (activeSettingsMenu && activeSettingsMenu.dataset.nodeId === nodeId) {
                removeSettingsMenu(); return;
            }
            removeContextMenu(); removeSettingsMenu();

            const menu = document.createElement('div');
            menu.classList.add('node-settings-menu');
            menu.dataset.nodeId = nodeId;
            
            node.settings = node.settings || {};

            let menuHtml = `<ul>`;
            menuHtml += `<li data-action="fetch-content"><i class="fas fa-paper-plane w-4 mr-2 text-blue-500"></i> Process / Send Data</li>`;
            menuHtml += `<div class="separator"></div>`;

            if (node.type === 'media' && node.fileType && node.fileType.startsWith('video')) {
                menuHtml += `
                    <li><label>
                        <input type="checkbox" data-setting="extractAudio" ${node.settings.extractAudio ? 'checked' : ''}>
                        Extract Audio
                    </label></li>`;
            }
            menuHtml += `
                <li><label>
                    <input type="checkbox" data-setting="runParallel" ${node.settings.runParallel ? 'checked' : ''}>
                    Run in Parallel
                </label></li>
                <li class="has-submenu">
                    Select AI Model
                    <i class="fas fa-chevron-right text-xs text-gray-400 ml-auto"></i>
                    <ul class="submenu">
                        <li data-setting="aiModel" data-value="gpt-4" class="${node.settings.aiModel === 'gpt-4' ? 'font-semibold text-blue-600' : ''}">GPT-4</li>
                        <li data-setting="aiModel" data-value="claude-3" class="${node.settings.aiModel === 'claude-3' ? 'font-semibold text-blue-600' : ''}">Claude 3</li>
                        <li data-setting="aiModel" data-value="gemini-pro" class="${node.settings.aiModel === 'gemini-pro' ? 'font-semibold text-blue-600' : ''}">Gemini Pro</li>
                        <li data-setting="aiModel" data-value="other-ai" class="${node.settings.aiModel === 'other-ai' ? 'font-semibold text-blue-600' : ''}">Other Model...</li>
                    </ul>
                </li>
                <li class="has-submenu">
                    Extract Speech Text
                    <i class="fas fa-chevron-right text-xs text-gray-400 ml-auto"></i>
                    <ul class="submenu">
                        <li data-setting="speechLang" data-value="en" class="${node.settings.speechLang === 'en' ? 'font-semibold text-blue-600' : ''}">English</li>
                        <li data-setting="speechLang" data-value="es" class="${node.settings.speechLang === 'es' ? 'font-semibold text-blue-600' : ''}">Spanish</li>
                        <li data-setting="speechLang" data-value="fr" class="${node.settings.speechLang === 'fr' ? 'font-semibold text-blue-600' : ''}">French</li>
                        <li data-setting="speechLang" data-value="de" class="${node.settings.speechLang === 'de' ? 'font-semibold text-blue-600' : ''}">German</li>
                        <li data-setting="speechLang" data-value="other-lang" class="${node.settings.speechLang === 'other-lang' ? 'font-semibold text-blue-600' : ''}">Other...</li>
                    </ul>
                </li>
                <li class="has-submenu">
                    Generate Audio from Text
                    <i class="fas fa-chevron-right text-xs text-gray-400 ml-auto"></i>
                    <ul class="submenu">
                        <li><label>
                            <input type="checkbox" data-setting="generateAudio" ${node.settings.generateAudio ? 'checked' : ''}>
                            Enable Audio Generation
                        </label></li>
                        <li data-setting="ttsModel" data-value="elevenlabs" class="${node.settings.ttsModel === 'elevenlabs' ? 'font-semibold text-blue-600' : ''}">ElevenLabs</li>
                        <li data-setting="ttsModel" data-value="gtts" class="${node.settings.ttsModel === 'gtts' ? 'font-semibold text-blue-600' : ''}">Google TTS</li>
                    </ul>
                </li>
                `;
            
            menuHtml += `<div class="separator"></div>`;
            menuHtml += `<li data-action="disconnect-all"><i class="fas fa-unlink w-4 mr-2 text-orange-500"></i> Disconnect All Lines</li>`;
            menuHtml += `<li data-action="delete-block" class="text-red-600 hover:bg-red-50 hover:text-red-700"><i class="fas fa-trash-alt w-4 mr-2"></i> Delete Block</li>`;
            menuHtml += `</ul>`;

            menu.innerHTML = menuHtml;
            document.body.appendChild(menu);
            activeSettingsMenu = menu;

            const nodeRect = node.element.getBoundingClientRect();
            const settingsIconRect = node.element.querySelector('.settings-icon').getBoundingClientRect();
            
            menu.style.left = `${settingsIconRect.right + window.scrollX + 5}px`;
            menu.style.top = `${settingsIconRect.top + window.scrollY - 5}px`;

            const menuRect = menu.getBoundingClientRect();
            const viewportWidth = window.innerWidth;
            const viewportHeight = window.innerHeight;

            if (menuRect.right > viewportWidth - 10) {
                menu.style.left = `${settingsIconRect.left + window.scrollX - menuRect.width - 5}px`;
                menu.style.transformOrigin = 'top left';
            }
            if (menuRect.bottom > viewportHeight - 10) {
                menu.style.top = `${settingsIconRect.bottom + window.scrollY - menuRect.height + 5}px`;
                menu.style.transformOrigin = 'bottom right';
            }
             if (menuRect.left < 10) {
                menu.style.left = '10px';
            }


            menu.querySelectorAll('input[type="checkbox"]').forEach(checkbox => {
                checkbox.addEventListener('change', (e) => {
                    e.stopPropagation();
                    const settingName = checkbox.dataset.setting;
                    node.settings[settingName] = checkbox.checked;
                    saveWorkflow();
                });
            });

            menu.querySelectorAll('.submenu li').forEach(subItem => {
                subItem.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const settingName = subItem.dataset.setting;
                    const value = subItem.dataset.value;
                    node.settings[settingName] = value;
                    
                    subItem.parentElement.querySelectorAll('li').forEach(li => li.classList.remove('font-semibold', 'text-blue-600'));
                    subItem.classList.add('font-semibold', 'text-blue-600');

                    saveWorkflow();
                    removeSettingsMenu(); 
                });
            });

            menu.querySelector('[data-action="fetch-content"]').addEventListener('click', (e) => {
                e.stopPropagation();
                if (node && typeof node.fetchContent === 'function') {
                    node.fetchContent();
                }
                removeSettingsMenu();
            });
            menu.querySelector('[data-action="disconnect-all"]').addEventListener('click', (e) => {
                e.stopPropagation();
                disconnectAllLinesFromNode(nodeId);
                removeSettingsMenu();
            });
            menu.querySelector('[data-action="delete-block"]').addEventListener('click', (e) => {
                e.stopPropagation();
                deleteNode(nodeId);
            });
            
            menu.querySelectorAll('li.has-submenu').forEach(parentLi => {
                parentLi.addEventListener('mouseenter', () => {
                    menu.querySelectorAll('.submenu').forEach(sm => {
                        if (sm !== parentLi.querySelector('.submenu')) {
                        }
                    });
                    const sub = parentLi.querySelector('.submenu');
                    if (sub) {
                    }
                });
            });


            setTimeout(() => menu.classList.add('show'), 10);
        }

        function removeSettingsMenu() { 
            if (activeSettingsMenu) {
                activeSettingsMenu.classList.remove('show');
                setTimeout(() => {
                    if (activeSettingsMenu && !activeSettingsMenu.classList.contains('show')) {
                         activeSettingsMenu.remove();
                         activeSettingsMenu = null;
                    }
                }, 200); 
            }
        }


        // --- Media Modal Functions ---
        function openVideoModal(videoUrl) { 
            modalVideo.src = videoUrl;
            videoModal.classList.add('show');
            modalVideo.play().catch(e => console.error("Video play error:", e));
        }
        function closeVideoModal() { 
            modalVideo.pause();
            modalVideo.src = ''; 
            videoModal.classList.remove('show');
        }
        closeModalButton.addEventListener('click', closeVideoModal);
        videoModal.addEventListener('click', (e) => { if (e.target === videoModal) closeVideoModal(); });

        // --- Code Preview Modal Functions ---
        function openCodePreviewModal(title, code) {
            document.getElementById('codePreviewTitle').textContent = title;
            codeOutput.textContent = code;
            codePreviewModal.classList.add('show');
        }

        function closeCodePreviewModal() {
            codePreviewModal.classList.remove('show');
            codeOutput.textContent = '';
        }
        closeCodePreviewModalButton.addEventListener('click', closeCodePreviewModal);
        codePreviewModal.addEventListener('click', (e) => {
            if (e.target === codePreviewModal) closeCodePreviewModal();
        });
        copyCodeBtn.addEventListener('click', () => {
            const textToCopy = codeOutput.textContent;
            const textarea = document.createElement('textarea');
            textarea.value = textToCopy;
            document.body.appendChild(textarea);
            textarea.select();
            try {
                document.execCommand('copy');
                showToast('Code copied to clipboard!');
            } catch (err) {
                console.error('Failed to copy text: ', err);
                showToast('Failed to copy code.', 3000);
            } finally {
                document.body.removeChild(textarea);
            }
        });


        // --- New Feature Implementations ---

        // 8. Editable Textbox to Title the Project
        projectTitleInput.addEventListener('input', () => {
            projectTitle = projectTitleInput.value;
            saveWorkflow();
        });

        // 6. Preview the Sequence of the Automation Process
        previewSequenceBtn.addEventListener('click', () => {
            const sequence = generateAutomationSequence();
            openCodePreviewModal('Automation Sequence Preview', JSON.stringify(sequence, null, 2));
        });

        function generateAutomationSequence() {
            const graph = new Map();
            const inDegree = new Map();
            const startNodes = [];
            const endNodes = [];

            nodes.forEach(node => {
                graph.set(node.id, { nodeData: node, nextNodes: [] });
                inDegree.set(node.id, 0);
                if (node.type === 'start') {
                    startNodes.push(node.id);
                } else if (node.type === 'end') {
                    endNodes.push(node.id);
                }
            });

            connections.forEach(conn => {
                if (graph.has(conn.from) && graph.has(conn.to)) {
                    graph.get(conn.from).nextNodes.push(conn.to);
                    inDegree.set(conn.to, inDegree.get(conn.to) + 1);
                }
            });

            const sequentialSteps = [];
            const explicitParallelBlocks = [];
            const trulyDisconnectedBlocks = [];
            const visitedForSequential = new Set();

            nodes.forEach(node => {
                if (node.settings.runParallel && node.type !== 'start' && node.type !== 'end' && node.type !== 'title-block') {
                    explicitParallelBlocks.push({
                        id: node.id,
                        title: node.title,
                        type: node.type,
                        description: node.description,
                        settings: node.settings,
                        selectedFile: node.selectedFile,
                        fileType: node.fileType,
                        recordedAudioFileName: node.recordedAudioFileName,
                        isExplicitParallel: true
                    });
                    visitedForSequential.add(node.id);
                }
            });

            const queue = [];
            // Add actual start nodes to the queue
            startNodes.forEach(nodeId => {
                if (!visitedForSequential.has(nodeId)) {
                    queue.push(nodeId);
                }
            });

            // Add other nodes with in-degree 0 that are not start/end/title nodes and not explicitly parallel
            inDegree.forEach((degree, nodeId) => {
                const node = nodes.find(n => n.id === nodeId);
                if (degree === 0 && !visitedForSequential.has(nodeId) && node.type !== 'start' && node.type !== 'end' && node.type !== 'title-block') {
                    queue.push(nodeId);
                }
            });

            let head = 0;
            while (head < queue.length) {
                const nodeId = queue[head++];
                if (visitedForSequential.has(nodeId)) continue;
                visitedForSequential.add(nodeId);

                const nodeInfo = graph.get(nodeId);
                if (nodeInfo) {
                    sequentialSteps.push({
                        id: nodeInfo.nodeData.id,
                        title: nodeInfo.nodeData.title,
                        type: nodeInfo.nodeData.type,
                        description: nodeInfo.nodeData.description,
                        settings: nodeInfo.nodeData.settings,
                        selectedFile: nodeInfo.nodeData.selectedFile,
                        fileType: nodeInfo.nodeData.fileType,
                        recordedAudioFileName: nodeInfo.nodeData.recordedAudioFileName,
                    });

                    nodeInfo.nextNodes.forEach(nextNodeId => {
                        if (!visitedForSequential.has(nextNodeId)) {
                            inDegree.set(nextNodeId, inDegree.get(nextNodeId) - 1);
                            if (inDegree.get(nextNodeId) === 0) {
                                queue.push(nextNodeId);
                            }
                        }
                    });
                }
            }

            nodes.forEach(node => {
                if (!visitedForSequential.has(node.id) && node.type !== 'start' && node.type !== 'end' && node.type !== 'title-block') {
                    trulyDisconnectedBlocks.push({
                        id: node.id,
                        title: node.title,
                        type: node.type,
                        description: node.description,
                        settings: node.settings,
                        selectedFile: node.selectedFile,
                        fileType: node.fileType,
                        recordedAudioFileName: node.recordedAudioFileName,
                        isTrulyDisconnected: true
                    });
                }
            });

            return {
                projectTitle: projectTitle,
                sequence: {
                    sequentialSteps: sequentialSteps,
                    explicitParallelBlocks: explicitParallelBlocks,
                    trulyDisconnectedBlocks: trulyDisconnectedBlocks
                },
                notes: "Sequential steps are ordered by dependencies. Explicit parallel blocks and truly disconnected blocks run concurrently."
            };
        }

        // 9. Add a button to save the code of the created project.
        saveCodeBtn.addEventListener('click', () => {
            saveWorkflow();
            saveFormatModal.classList.add('show'); // Open the format selection modal
        });

        function getProjectDataAsObject() {
            return {
                projectTitle: projectTitle,
                nodes: nodes.map(node => ({
                    id: node.id,
                    type: node.type,
                    x: node.x,
                    y: node.y,
                    width: node.width,
                    height: node.height,
                    title: node.title,
                    description: node.description,
                    settings: { ...node.settings },
                    selectedFile: node.selectedFile,
                    fileType: node.fileType,
                    recordedAudioFileName: node.recordedAudioBlob ? `${node.id}_recording.webm` : null, 
                })),
                connections: connections.map(conn => ({ ...conn })),
                nodeIdCounter: nodeIdCounter,
                connectionIdCounter: connectionIdCounter,
            };
        }

        saveAsJsonBtn.addEventListener('click', () => {
            const data = getProjectDataAsObject();
            const jsonString = JSON.stringify(data, null, 2);
            openCodePreviewModal('Project Configuration (JSON)', jsonString);
            saveFormatModal.classList.remove('show');
        });

        saveAsYamlBtn.addEventListener('click', () => {
            const data = getProjectDataAsObject();
            // Simple simulation of YAML. For a real YAML converter, a library would be needed.
            let yamlString = `projectTitle: "${data.projectTitle}"\n`;
            yamlString += `nodes:\n`;
            data.nodes.forEach(node => {
                yamlString += `  - id: "${node.id}"\n`;
                yamlString += `    type: "${node.type}"\n`;
                yamlString += `    title: "${node.title}"\n`;
                if (node.description) yamlString += `    description: "${node.description}"\n`;
                yamlString += `    x: ${node.x}\n`;
                yamlString += `    y: ${node.y}\n`;
                yamlString += `    width: ${node.width}\n`;
                yamlString += `    height: ${node.height}\n`;
                if (Object.keys(node.settings).length > 0) {
                    yamlString += `    settings:\n`;
                    for (const key in node.settings) {
                        yamlString += `      ${key}: ${JSON.stringify(node.settings[key])}\n`;
                    }
                }
                if (node.selectedFile) yamlString += `    selectedFile: "${node.selectedFile}"\n`;
                if (node.fileType) yamlString += `    fileType: "${node.fileType}"\n`;
                if (node.recordedAudioFileName) yamlString += `    recordedAudioFileName: "${node.recordedAudioFileName}"\n`;
            });
            yamlString += `connections:\n`;
            data.connections.forEach(conn => {
                yamlString += `  - id: "${conn.id}"\n`;
                yamlString += `    from: "${conn.from}"\n`;
                yamlString += `    to: "${conn.to}"\n`;
                yamlString += `    style: "${conn.style}"\n`;
            });
            yamlString += `nodeIdCounter: ${data.nodeIdCounter}\n`;
            yamlString += `connectionIdCounter: ${data.connectionIdCounter}\n`;

            openCodePreviewModal('Project Configuration (YAML)', yamlString);
            saveFormatModal.classList.remove('show');
        });

        saveAsXmlBtn.addEventListener('click', () => {
            const data = getProjectDataAsObject();
            // Simple simulation of XML. For a real XML converter, a library or more complex logic would be needed.
            let xmlString = `<?xml version="1.0" encoding="UTF-8"?>\n`;
            xmlString += `<WorkflowProject>\n`;
            xmlString += `  <ProjectTitle>${escapeXml(data.projectTitle)}</ProjectTitle>\n`;
            xmlString += `  <Nodes>\n`;
            data.nodes.forEach(node => {
                xmlString += `    <Node id="${node.id}" type="${node.type}">\n`;
                xmlString += `      <Title>${escapeXml(node.title)}</Title>\n`;
                if (node.description) xmlString += `      <Description>${escapeXml(node.description)}</Description>\n`;
                xmlString += `      <Position x="${node.x}" y="${node.y}"/>\n`;
                xmlString += `      <Size width="${node.width}" height="${node.height}"/>\n`;
                if (Object.keys(node.settings).length > 0) {
                    xmlString += `      <Settings>\n`;
                    for (const key in node.settings) {
                        xmlString += `        <Setting name="${key}">${escapeXml(JSON.stringify(node.settings[key]))}</Setting>\n`;
                    }
                    xmlString += `      </Settings>\n`;
                }
                if (node.selectedFile) xmlString += `      <SelectedFile>${escapeXml(node.selectedFile)}</SelectedFile>\n`;
                if (node.fileType) xmlString += `      <FileType>${escapeXml(node.fileType)}</FileType>\n`;
                if (node.recordedAudioFileName) xmlString += `      <RecordedAudioFileName>${escapeXml(node.recordedAudioFileName)}</RecordedAudioFileName>\n`;
                xmlString += `    </Node>\n`;
            });
            xmlString += `  </Nodes>\n`;
            xmlString += `  <Connections>\n`;
            data.connections.forEach(conn => {
                xmlString += `    <Connection id="${conn.id}" from="${conn.from}" to="${conn.to}" style="${conn.style}"/>\n`;
            });
            xmlString += `  </Connections>\n`;
            xmlString += `  <NodeIdCounter>${data.nodeIdCounter}</NodeIdCounter>\n`;
            xmlString += `  <ConnectionIdCounter>${data.connectionIdCounter}</ConnectionIdCounter>\n`;
            xmlString += `</WorkflowProject>\n`;

            openCodePreviewModal('Project Configuration (XML)', xmlString);
            saveFormatModal.classList.remove('show');
        });

        function escapeXml(unsafe) {
            return unsafe.replace(/[<>&'"]/g, function (c) {
                switch (c) {
                    case '<': return '&lt;';
                    case '>': return '&gt;';
                    case '&': return '&amp;';
                    case "'": return '&apos;';
                    case '"': return '&quot;';
                }
            });
        }

        // 10. Add a button to download an image of the project.
        downloadImageBtn.addEventListener('click', () => {
            showToast('Generating image...', 1500);
            const actionButtons = document.getElementById('actionButtonsContainer');
            const header = document.querySelector('.header-container');
            if (actionButtons) actionButtons.style.display = 'none';
            if (header) header.style.display = 'none';

            html2canvas(workflowCanvas, {
                scrollX: -workflowCanvas.scrollLeft,
                scrollY: -workflowCanvas.scrollTop,
                width: workflowCanvas.scrollWidth,
                height: workflowCanvas.scrollHeight,
                useCORS: true,
                backgroundColor: '#f0f2f5',
            }).then(canvas => {
                if (actionButtons) actionButtons.style.display = 'flex';
                if (header) header.style.display = 'flex';

                const image = canvas.toDataURL('image/png');
                const link = document.createElement('a');
                link.download = `${projectTitle.replace(/\s+/g, '_') || 'workflow'}_${new Date().toISOString().slice(0,10)}.png`;
                link.href = image;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                showToast('Image downloaded!', 1500);
            }).catch(error => {
                console.error('Error generating image:', error);
                showToast('Failed to download image.', 3000);
                if (actionButtons) actionButtons.style.display = 'flex';
                if (header) header.style.display = 'flex';
            });
        });

        // New: Start Process Button Handler
        startProcessBtn.addEventListener('click', startAutomationProcess);

        // New: Global Stop Process Button Handler
        stopProcessBtn.addEventListener('click', () => {
            showToast('Stopping all active processes...', 2000);
            nodes.forEach(node => {
                if (node.abortController) {
                    node.abortController.abort();
                }
            });
            stopProcessBtn.disabled = true;
            startProcessBtn.disabled = false;
        });

        // Function to update 'runParallel' setting for disconnected nodes
        function updateDisconnectedNodesParallelSetting() {
            const connectedNodeIds = new Set();
            connections.forEach(conn => {
                connectedNodeIds.add(conn.from);
                connectedNodeIds.add(conn.to);
            });

            nodes.forEach(node => {
                // If a node is not explicitly connected (neither source nor target of any connection)
                // and it's not a 'start' or 'end' or 'title-block' node
                if (!connectedNodeIds.has(node.id) && node.type !== 'start' && node.type !== 'end' && node.type !== 'title-block') {
                    node.settings.runParallel = true;
                    console.log(`Node ${node.id} ("${node.title}") is disconnected, setting runParallel to true.`);
                } else {
                    // If it is connected, ensure runParallel is false unless explicitly set by user
                    if (node.settings.runParallel === undefined) {
                        node.settings.runParallel = false;
                    }
                }
            });
            saveWorkflow(); // Save the updated settings
        }

        async function startAutomationProcess() {
            showToast('Starting automation process...', 2000);

            successFloatingButton.style.display = 'none';

            startProcessBtn.disabled = true;
            stopProcessBtn.disabled = false;

            // Update parallel settings for disconnected nodes before generating sequence
            updateDisconnectedNodesParallelSetting();

            const workflowData = generateAutomationSequence();
            const sequentialSteps = workflowData.sequence.sequentialSteps;
            const explicitParallelBlocks = workflowData.sequence.explicitParallelBlocks;
            const trulyDisconnectedBlocks = workflowData.sequence.trulyDisconnectedBlocks;

            nodes.forEach(node => {
                node.isLoading = false;
                node.hasError = false;
                node.errorMessage = '';
                node.element.querySelector('.node-spinner').style.display = 'none';
                node.element.querySelector('.node-alert-icon').style.display = 'none';
                node.element.querySelector('.node-success-icon').style.display = 'none'; // Reset success icon
                const stopBtn = node.element.querySelector('.stop-node-btn');
                if (stopBtn) stopBtn.classList.add('hidden');
                const llmButton = node.element.querySelector('.llm-button');
                if (llmButton) llmButton.disabled = false;
            });

            let validationFailed = false;
            const allNodesForValidation = [...sequentialSteps, ...explicitParallelBlocks, ...trulyDisconnectedBlocks];
            for (const stepData of allNodesForValidation) {
                const node = nodes.find(n => n.id === stepData.id);
                // Only validate/fetch for non-start/end/title blocks
                if (node && node.type !== 'start' && node.type !== 'end' && node.type !== 'title-block' && stopProcessBtn.disabled === false && !await node.fetchContent(true)) {
                    validationFailed = true;
                    break;
                }
            }
            if (validationFailed) {
                showToast(`Process stopped due to validation error. Please check highlighted blocks.`, 3000);
                startProcessBtn.disabled = false;
                stopProcessBtn.disabled = true;
                return;
            }

            const concurrentExecutionPromises = [];
            explicitParallelBlocks.forEach(stepData => {
                const node = nodes.find(n => n.id === stepData.id);
                if (node && stopProcessBtn.disabled === false) {
                    console.log(`Executing explicit parallel block: ${node.title} (${node.id})`);
                    concurrentExecutionPromises.push(node.fetchContent());
                }
            });
            trulyDisconnectedBlocks.forEach(stepData => {
                const node = nodes.find(n => n.id === stepData.id);
                if (node && stopProcessBtn.disabled === false) {
                    console.log(`Executing truly disconnected block: ${node.title} (${node.id})`);
                    concurrentExecutionPromises.push(node.fetchContent());
                }
            });

            const concurrentResultsPromise = Promise.allSettled(concurrentExecutionPromises);

            let sequentialExecutionFailed = false;
            for (const stepData of sequentialSteps) {
                const node = nodes.find(n => n.id === stepData.id);
                if (node && stopProcessBtn.disabled === false) {
                    console.log(`Executing sequential step: ${node.title} (${node.id})`);
                    // Only fetch content for non-start/end/title blocks
                    const success = (node.type === 'start' || node.type === 'end' || node.type === 'title-block') ? true : await node.fetchContent();
                    if (!success) {
                        sequentialExecutionFailed = true;
                        showToast(`Process stopped due to error in sequential step: "${node.title}".`, 3000);
                        break;
                    }
                } else if (stopProcessBtn.disabled === true) {
                    console.log("Sequential process stopped by user.");
                    sequentialExecutionFailed = true;
                    break;
                }
            }

            await concurrentResultsPromise;

            let overallSuccess = true;
            let parallelErrorsOccurred = false;

            nodes.forEach(node => {
                if (node.hasError) {
                    overallSuccess = false;
                    if (sequentialSteps.some(s => s.id === node.id)) {
                    } else {
                        parallelErrorsOccurred = true;
                    }
                }
            });

            startProcessBtn.disabled = false;
            stopProcessBtn.disabled = true;

            if (sequentialExecutionFailed) {
            } else if (overallSuccess) {
                showToast('Automation process completed successfully!', 3000);
                successFloatingButton.style.display = 'flex';
                displaySuccessResponseModal();
            } else if (parallelErrorsOccurred) {
                showToast('Automation process completed with some errors in parallel blocks.', 4000);
                successFloatingButton.style.display = 'flex';
                displaySuccessResponseModal();
            }
        }

        function displaySuccessResponseModal() {
            const simulatedServerResponse = {
                status: nodes.some(node => node.hasError) ? "completed_with_errors" : "success",
                message: nodes.some(node => node.hasError) ? "Workflow processes completed, but some blocks encountered errors." : "All workflow processes completed successfully!",
                results: nodes.map(node => ({
                    nodeId: node.id,
                    nodeTitle: node.title,
                    status: node.hasError ? "failed" : "completed",
                    errorMessage: node.hasError ? node.errorMessage : null,
                    output: node.hasError ? null : `Simulated output for ${node.title}`
                })),
                timestamp: new Date().toISOString()
            };
            openCodePreviewModal('Workflow Execution Summary', JSON.stringify(simulatedServerResponse, null, 2));
        }

        // --- Saved Projects Modal Functions ---
        savedProjectsBtn.addEventListener('click', openSavedProjectsModal);

        async function openSavedProjectsModal() {
            if (!db || !userId) {
                showAlertModal('Authentication Required', 'Please ensure you are signed in to view saved projects.');
                return;
            }
            savedProjectsList.innerHTML = '<li class="no-projects">Loading projects...</li>';
            savedProjectsModal.classList.add('show');
            await loadSavedProjectsList();
        }

        function closeSavedProjectsModal() {
            savedProjectsModal.classList.remove('show');
        }
        closeSavedProjectsModalButton.addEventListener('click', closeSavedProjectsModal);
        savedProjectsModal.addEventListener('click', (e) => {
            if (e.target === savedProjectsModal) closeSavedProjectsModal();
        });

        async function loadSavedProjectsList() {
            savedProjectsList.innerHTML = ''; // Clear previous list
            try {
                const querySnapshot = await getDocs(collection(db, `artifacts/${appId}/users/${userId}/workflows`));
                if (querySnapshot.empty) {
                    savedProjectsList.innerHTML = '<li class="no-projects">No saved projects found.</li>';
                    return;
                }

                querySnapshot.forEach(docSnap => {
                    const data = docSnap.data();
                    const projectId = docSnap.id;
                    const projectTitle = data.projectTitle || `Project ${projectId}`;
                    const lastUpdated = data.updatedAt ? new Date(data.updatedAt.seconds * 1000).toLocaleString() : 'N/A';

                    const listItem = document.createElement('li');
                    listItem.innerHTML = `
                        <div class="project-info">
                            <span class="project-title">${projectTitle}</span>
                            <span class="project-date">Last updated: ${lastUpdated}</span>
                        </div>
                        <div class="project-actions">
                            <button data-action="load" data-project-id="${projectId}">Load</button>
                            <button data-action="delete" data-project-id="${projectId}" class="delete-btn">Delete</button>
                        </div>
                    `;
                    savedProjectsList.appendChild(listItem);
                });

                savedProjectsList.querySelectorAll('button[data-action="load"]').forEach(button => {
                    button.addEventListener('click', async (e) => {
                        const projectId = e.target.dataset.projectId;
                        closeSavedProjectsModal();
                        await loadWorkflow(projectId);
                    });
                });

                savedProjectsList.querySelectorAll('button[data-action="delete"]').forEach(button => {
                    button.addEventListener('click', async (e) => {
                        const projectId = e.target.dataset.projectId;
                        if (confirm(`Are you sure you want to delete project "${projectId}"?`)) { // Using confirm for simplicity, replace with custom modal
                            await deleteProject(projectId);
                            await loadSavedProjectsList(); // Refresh list after deletion
                        }
                    });
                });

            } catch (error) {
                console.error("Error loading saved projects list:", error);
                savedProjectsList.innerHTML = '<li class="no-projects text-red-500">Error loading projects.</li>';
                showAlertModal('Error', 'Failed to load saved projects. Please try again.');
            }
        }

        async function deleteProject(projectId) {
            if (!db || !userId) {
                showAlertModal('Authentication Required', 'Cannot delete project. Please sign in.');
                return;
            }
            try {
                await deleteDoc(doc(db, `artifacts/${appId}/users/${userId}/workflows/${projectId}`));
                showToast(`Project "${projectId}" deleted.`, 2000);
                // If the deleted project was the currently loaded one, load the default
                if (projectId === 'defaultWorkflow' || projectId === projectTitleInput.value) {
                    loadWorkflow('defaultWorkflow'); // Load default after deleting current
                }
            } catch (error) {
                console.error("Error deleting project:", error);
                showAlertModal('Deletion Error', `Failed to delete project "${projectId}".`);
            }
        }


        // --- Global Event Listeners ---
        deleteSelectedItemBtn.addEventListener('click', () => { 
            if (selectedItem) {
                if (selectedItem.element) { deleteNode(selectedItem.id); } 
                else { deleteConnection(selectedItem.id); } 
            }
            removeContextMenu(); removeSettingsMenu();
        });
        
        const handleMove = (clientX, clientY) => { 
            if (!activeDrag && !currentlyDrawingLine) return;

            if (activeDrag) {
                if (activeDrag.isNew) {
                    activeDrag.ghostElement.style.left = `${clientX - activeDrag.offsetX}px`;
                    activeDrag.ghostElement.style.top = `${clientY - activeDrag.offsetY}px`;
                } else if (activeDrag.element) {
                    const canvasRect = workflowCanvas.getBoundingClientRect();
                    let newX = clientX - canvasRect.left + workflowCanvas.scrollLeft - activeDrag.offsetX;
                    let newY = clientY - canvasRect.top + workflowCanvas.scrollTop - activeDrag.offsetY;
                    
                    activeDrag.data.x = newX; activeDrag.data.y = newY;
                    activeDrag.element.style.left = `${newX}px`; activeDrag.element.style.top = `${newY}px`;
                    updateAllConnections();
                }
            } else if (currentlyDrawingLine) {
                const line = currentlyDrawingLine.lineElement;
                const canvasRect = workflowCanvas.getBoundingClientRect();
                const svgX = clientX - canvasRect.left + workflowCanvas.scrollLeft;
                const svgY = clientY - canvasRect.top + workflowCanvas.scrollTop;
                const startPos = getConnectorPosition(nodes.find(n => n.id === currentlyDrawingLine.startNodeId), 'output');
                const dx = Math.abs(startPos.x - svgX);
                const cp1x = startPos.x + dx * 0.6; const cp1y = startPos.y;
                const cp2x = svgX - dx * 0.6;   const cp2y = svgY;
                line.setAttribute('d', `M ${startPos.x} ${startPos.y} C ${cp1x} ${cp1y}, ${cp2x} ${cp2y}, ${svgX} ${svgY}`);
            }
        };

        const handleEnd = (clientX, clientY) => { 
            if (activeDrag) {
                if (activeDrag.isNew) {
                    if (activeDrag.ghostElement) activeDrag.ghostElement.remove();
                    const canvasContainerRect = workflowCanvasContainer.getBoundingClientRect();
                    if (clientX >= canvasContainerRect.left && clientX <= canvasContainerRect.right &&
                        clientY >= canvasContainerRect.top && clientY <= canvasContainerRect.bottom) {
                        createNode(clientX, clientY, activeDrag.type, activeDrag.initialTitle, activeDrag.initialDescription);
                    }
                } else if (activeDrag.element) {
                    activeDrag.element.style.cursor = 'grab'; activeDrag.element.style.zIndex = '10'; 
                    activeDrag.data.width = activeDrag.element.offsetWidth; 
                    activeDrag.data.height = activeDrag.element.offsetHeight;
                    updateAllConnections(); 
                    saveWorkflow(); 
                }
                activeDrag = null;
            }
            if (currentlyDrawingLine) {
                const tempLine = currentlyDrawingLine.lineElement;
                const isConnected = connections.some(c => {
                    const lineEl = document.getElementById(c.id);
                    return lineEl === tempLine;
                });

                if (tempLine && connectionsSvg.contains(tempLine) && !isConnected) {
                    connectionsSvg.removeChild(tempLine);
                }
                currentlyDrawingLine = null;
            }
        };

        document.addEventListener('mousemove', (e) => handleMove(e.clientX, e.clientY));
        document.addEventListener('touchmove', (e) => {
            if (e.touches.length === 1) {
                if (activeDrag || currentlyDrawingLine) e.preventDefault();
                handleMove(e.touches[0].clientX, e.touches[0].clientY);
            }
        }, { passive: false });
        document.addEventListener('mouseup', (e) => handleEnd(e.clientX, e.clientY));
        document.addEventListener('touchend', (e) => {
            const touch = e.changedTouches && e.changedTouches.length > 0 ? e.changedTouches[0] : null;
            handleEnd(touch ? touch.clientX : undefined, touch ? touch.clientY : undefined);
        });
        
        document.addEventListener('mousedown', (e) => { 
            let clickedOnInteractiveUI = e.target.closest('#nodeContextMenu, #actionButtonsContainer, #videoModal, #codePreviewModal, .node-settings-menu, .toolbox, #alertModal, #projectTitleInput, .header-buttons, #successFloatingButton, #userProfileMenu, #userProfileImage, .llm-button, .stop-node-btn, #savedProjectsModal, #saveFormatModal'); // Added saveFormatModal
            if (e.target.closest('.toolbox')) return;

            if (contextMenuElement && !e.target.closest('#nodeContextMenu')) removeContextMenu();
            if (activeSettingsMenu && !e.target.closest('.node-settings-menu')) removeSettingsMenu();
            if (userProfileMenu.classList.contains('show') && !e.target.closest('.user-profile-container')) {
                userProfileMenu.classList.remove('show');
            }
            if (savedProjectsModal.classList.contains('show') && !e.target.closest('#savedProjectsModal')) {
                closeSavedProjectsModal();
            }
            if (saveFormatModal.classList.contains('show') && !e.target.closest('#saveFormatModal .modal-content')) { // Close save format modal
                saveFormatModal.classList.remove('show');
            }
            
            if (!clickedOnInteractiveUI && 
                (e.target === workflowCanvas || e.target === connectionsSvg || e.target === workflowCanvasContainer) &&
                !e.target.closest('.node') && !e.target.closest('.connector-point') &&
                !currentlyDrawingLine) { 
                deselectAll();
            }
        }, true); 

        document.addEventListener('keydown', (e) => { 
            if (e.key === 'Escape') {
                if (alertModal.classList.contains('show')) alertModal.classList.remove('show');
                else if (videoModal.classList.contains('show')) closeVideoModal();
                else if (codePreviewModal.classList.contains('show')) closeCodePreviewModal();
                else if (savedProjectsModal.classList.contains('show')) closeSavedProjectsModal(); // New
                else if (saveFormatModal.classList.contains('show')) saveFormatModal.classList.remove('show'); // New
                else if (contextMenuElement) removeContextMenu();
                else if (activeSettingsMenu) removeSettingsMenu();
                else if (userProfileMenu.classList.contains('show')) userProfileMenu.classList.remove('show');
                else if (document.activeElement && (document.activeElement.isContentEditable || ['INPUT', 'TEXTAREA'].includes(document.activeElement.tagName))) {
                    document.activeElement.blur();
                } else if (currentlyDrawingLine && currentlyDrawingLine.lineElement) {
                    if (connectionsSvg.contains(currentlyDrawingLine.lineElement)) connectionsSvg.removeChild(currentlyDrawingLine.lineElement);
                    currentlyDrawingLine = null;
                } else if (activeDrag && activeDrag.isNew && activeDrag.ghostElement) {
                    activeDrag.ghostElement.remove(); activeDrag = null;
                }
                else deselectAll();
            }
            if ((e.key === 'Delete' || e.key === 'Backspace') && !e.target.closest('input, textarea, [contenteditable=true]')) {
                if (selectedItem) deleteSelectedItemBtn.click(); 
                if (contextMenuElement) removeContextMenu();
                if (activeSettingsMenu) removeSettingsMenu();
            }
        });
        
        successFloatingButton.addEventListener('click', () => {
            displaySuccessResponseModal();
        });

        userProfileImage.addEventListener('click', (e) => {
            e.stopPropagation();
            userProfileMenu.classList.toggle('show');
        });

        // Initial setup
        async function main() {
            setupToolboxEvents();
            await initializeFirebase(); 
            updateAllConnections(); 
            window.addEventListener('resize', updateAllConnections); 
            new ResizeObserver(updateAllConnections).observe(workflowCanvas);
             workflowCanvas.addEventListener('scroll', () => {
                updateAllConnections();
            });
        }

        main();

    </script>
</body>
</html>
