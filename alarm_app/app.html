<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Alarm Clock & Calendar</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f2f5; /* Light gray background */
            transition: background-color 0.3s ease;
        }
        body.dark-theme {
            background-color: #1a202c; /* Dark background */
            color: #e2e8f0; /* Light text */
        }
        body.dark-theme .bg-white {
            background-color: #2d3748; /* Darker card background */
        }
        body.dark-theme .text-gray-800 {
            color: #e2e8f0;
        }
        body.dark-theme .text-gray-700 {
            color: #cbd5e0;
        }
        body.dark-theme .text-gray-500 {
            color: #a0aec0;
        }
        body.dark-theme .text-blue-600, body.dark-theme .text-blue-700 {
            color: #90cdf4; /* Lighter blue for dark theme */
        }
        body.dark-theme .bg-gray-50 {
            background-color: #4a5568; /* Darker input/list background */
        }
        body.dark-theme .bg-blue-50 {
            background-color: #3182ce; /* Darker blue background for calendar */
            color: #e2e8f0;
        }
        body.dark-theme input, body.dark-theme select, body.dark-theme textarea {
            background-color: #2d3748;
            border-color: #4a5568;
            color: #e2e8f0;
        }
        body.dark-theme input:focus, body.dark-theme select:focus, body.dark-theme textarea:focus {
            --tw-ring-color: #90cdf4;
        }
        body.dark-theme .btn-nav {
            background-color: #4a5568;
            color: #e2e8f0;
        }
        body.dark-theme .btn-nav:hover {
            background-color: #636b7b;
        }
        body.dark-theme .calendar-day {
            background-color: #2d3748;
            color: #e2e8f0;
        }
        body.dark-theme .calendar-day:hover {
            background-color: #4a5568;
        }
        body.dark-theme .calendar-day.current-day {
            background-color: #48bb78; /* Green for current day in dark theme */
            border-color: #38a169;
        }
        body.dark-theme .calendar-day.selected-day {
            background-color: #63b3ed; /* Selected day in dark theme */
            border-color: #4299e1;
        }
        body.dark-theme .calendar-day.has-alarm {
            background-color: #2b6cb0; /* Light blue for days with alarms in dark theme */
            border-color: #3182ce;
        }
        body.dark-theme .modal-content {
            background-color: #2d3748;
            color: #e2e8f0;
        }
        body.dark-theme .modal-content h4 {
            color: #e2e8f0;
        }
        body.dark-theme .modal-content p {
            color: #cbd5e0;
        }

        /* Custom scrollbar for alarm list */
        .alarm-list-container::-webkit-scrollbar, .chatbot-messages::-webkit-scrollbar {
            width: 8px;
        }
        .alarm-list-container::-webkit-scrollbar-track, .chatbot-messages::-webkit-scrollbar-track {
            background: #e0e0e0;
            border-radius: 10px;
        }
        .alarm-list-container::-webkit-scrollbar-thumb, .chatbot-messages::-webkit-scrollbar-thumb {
            background: #a0a0a0;
            border-radius: 10px;
        }
        .alarm-list-container::-webkit-scrollbar-thumb:hover, .chatbot-messages::-webkit-scrollbar-thumb:hover {
            background: #808080;
        }
        body.dark-theme .alarm-list-container::-webkit-scrollbar-track, body.dark-theme .chatbot-messages::-webkit-scrollbar-track {
            background: #4a5568;
        }
        body.dark-theme .alarm-list-container::-webkit-scrollbar-thumb, body.dark-theme .chatbot-messages::-webkit-scrollbar-thumb {
            background: #636b7b;
        }
        body.dark-theme .alarm-list-container::-webkit-scrollbar-thumb:hover, body.dark-theme .chatbot-messages::-webkit-scrollbar-thumb:hover {
            background: #718096;
        }

        .calendar-day.has-alarm {
            background-color: #e0f2fe;
            border: 1px solid #0ea5e9;
            position: relative;
        }
        .calendar-day.current-day {
            background-color: #d1e7dd;
            border: 1px solid #28a745;
        }
        .calendar-day.selected-day {
            background-color: #cce5ff;
            border: 2px solid #007bff;
        }
        .calendar-day.current-day.selected-day {
            background-color: #b8e2b8;
            border: 2px solid #28a745;
        }

        /* Basic button styling */
        .btn-primary {
            @apply bg-gradient-to-r from-blue-500 to-blue-600 text-white font-semibold py-2 px-4 rounded-lg shadow-md hover:from-blue-600 hover:to-blue-700 transition-all duration-300 ease-in-out transform hover:scale-105;
        }
        .btn-secondary {
            @apply bg-gradient-to-r from-gray-400 to-gray-500 text-white font-semibold py-2 px-4 rounded-lg shadow-md hover:from-gray-500 hover:to-gray-600 transition-all duration-300 ease-in-out transform hover:scale-105;
        }
        .btn-danger {
            @apply bg-gradient-to-r from-red-500 to-red-600 text-white font-semibold py-1 px-3 rounded-lg shadow-sm hover:from-red-600 hover:to-red-700 transition-all duration-300 ease-in-out transform hover:scale-105 text-sm;
        }
        .btn-icon {
            @apply bg-white text-gray-700 p-2 rounded-full shadow-md hover:bg-gray-100 transition-all duration-300 ease-in-out flex items-center justify-center;
        }
        body.dark-theme .btn-icon {
            background-color: #4a5568;
            color: #e2e8f0;
        }
        body.dark-theme .btn-icon:hover {
            background-color: #636b7b;
        }
        .btn-icon svg {
            width: 20px;
            height: 20px;
        }

        /* Modal specific styles */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0,0,0,0.4);
            display: flex;
            justify-content: center;
            align-items: center;
        }
        .modal-content {
            background-color: #fff;
            margin: auto;
            padding: 24px;
            border-radius: 12px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
            width: 90%;
            max-width: 400px;
            text-align: center;
            transform: translateY(-20px);
            opacity: 0;
            animation: fadeInModal 0.3s forwards;
        }
        @keyframes fadeInModal { to { transform: translateY(0); opacity: 1; } }
        .modal-buttons {
            display: flex;
            justify-content: center;
            gap: 16px;
            margin-top: 24px;
        }
        #settings-modal .modal-content, #chatbot-modal .modal-content, #login-modal .modal-content, #register-modal .modal-content, #prompt-modal .modal-content {
            padding: 20px;
            border-radius: 15px;
            max-width: 420px;
            box-shadow: 0 15px 30px rgba(0, 0, 0, 0.25);
            animation: fadeInGrow 0.3s ease-out forwards;
        }
        @keyframes fadeInGrow { from { opacity: 0; transform: scale(0.9) translateY(-20px); } to { opacity: 1; transform: scale(1) translateY(0); } }
        #settings-modal .modal-content h4, #chatbot-modal .modal-content h4, #login-modal .modal-content h4, #register-modal .modal-content h4, #prompt-modal .modal-content h4 { font-size: 1.5rem; margin-bottom: 1.25rem; }

        /* Toggle switch styling */
        .toggle-switch { position: relative; display: inline-block; width: 48px; height: 28px; }
        .toggle-switch input { opacity: 0; width: 0; height: 0; }
        .slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #ccc; transition: .4s; border-radius: 28px; }
        .slider:before { position: absolute; content: ""; height: 20px; width: 20px; left: 4px; bottom: 4px; background-color: white; transition: .4s; border-radius: 50%; }
        input:checked + .slider { background-color: #2196F3; }
        input:checked + .slider:before { transform: translateX(20px); }

        /* Tooltip styles */
        #calendar-tooltip {
            position: absolute;
            background-color: #333;
            color: #fff;
            padding: 8px 12px;
            border-radius: 8px;
            font-size: 0.85rem;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s ease-in-out;
            z-index: 1001;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
            max-width: 250px;
            text-align: left;
            line-height: 1.4;
            transform: translateY(-10px); /* Initial subtle lift */
        }
        body.dark-theme #calendar-tooltip { background-color: #e2e8f0; color: #1a202c; }
        #calendar-tooltip ul { list-style: none; padding: 0; margin: 0; }
        #calendar-tooltip li { margin-bottom: 4px; }
        #calendar-tooltip li:last-child { margin-bottom: 0; }
        
        .speaker-btn-small { @apply bg-blue-100 text-blue-700 p-1 rounded-full hover:bg-blue-200 transition-colors duration-200 ml-2 flex-shrink-0; }
        .speaker-btn-small svg { width: 16px; height: 16px; vertical-align: middle; }
        body.dark-theme .speaker-btn-small { background-color: #3182ce; color: #e2e8f0; }
        body.dark-theme .speaker-btn-small:hover { background-color: #4299e1; }

        /* Floating buttons style */
        .floating-btn { position: fixed; z-index: 999; border-radius: 9999px; width: auto; padding: 1rem; box-shadow: 0 10px 20px rgba(0,0,0,0.2); transition: all 0.3s ease-in-out; }
        .floating-btn:hover { transform: scale(1.1); }
        #set-alarm-btn { bottom: 20px; right: 20px; font-size: 1.25rem; padding: 1rem 2rem; }
        #chatbot-btn { bottom: 20px; left: 20px; }

        /* Chatbot Modal Styles */
        #chatbot-modal .modal-content { max-width: 450px; }
        .chatbot-messages { height: 300px; overflow-y: auto; padding: 10px; background-color: #f9fafb; border-radius: 8px; border: 1px solid #e5e7eb; text-align: left; margin-bottom: 1rem; }
        body.dark-theme .chatbot-messages { background-color: #4a5568; border-color: #2d3748; }
        .chat-message { padding: 8px 12px; border-radius: 12px; margin-bottom: 8px; max-width: 80%; word-wrap: break-word; }
        .user-message { background-color: #dbeafe; color: #1e40af; margin-left: auto; border-bottom-right-radius: 2px; }
        .bot-message { background-color: #e5e7eb; color: #374151; margin-right: auto; border-bottom-left-radius: 2px; }
        body.dark-theme .user-message { background-color: #4299e1; color: #1a202c; }
        body.dark-theme .bot-message { background-color: #2d3748; color: #e2e8f0; }

        @media (max-width: 768px) {
            #set-alarm-btn { bottom: 15px; right: 15px; padding: 0.8rem 1.5rem; font-size: 1rem; }
            #chatbot-btn { bottom: 15px; left: 15px; }
        }

        /* Custom style for struck-through blue text */
        .strike-blue {
            text-decoration: line-through;
            text-decoration-color: #3b82f6; /* Tailwind blue-500 */
        }
        body.dark-theme .strike-blue {
            text-decoration-color: #60a5fa; /* A slightly lighter blue for dark theme readability */
        }

        .hidden { display: none !important; }
    </style>
</head>
<body class="flex items-center justify-center min-h-screen p-4">
    <div id="app-container" class="flex flex-col lg:flex-row bg-white rounded-xl shadow-2xl p-6 lg:p-8 space-y-8 lg:space-y-0 lg:space-x-8 max-w-7xl w-full hidden">
        <!-- Left Section -->
        <div class="flex-1 space-y-6">
            <div class="flex justify-between items-center mb-4">
                <div class="text-center flex-1">
                    <h1 class="text-4xl font-extrabold text-gray-800 mb-2">Alarm Clock</h1>
                    <p id="current-time" class="text-6xl font-light text-blue-600 animate-pulse"></p>
                    <p id="current-date" class="text-xl text-gray-500 mt-2"></p>
                </div>
                <div class="flex items-center space-x-2">
                    <button id="request-notification-permission" class="btn-icon" title="Enable Notifications"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M6 8a6 6 0 0 1 12 0c0 7 3 9 3 9H3s3-2 3-9"/><path d="M10.3 21a1.94 1.94 0 0 0 3.4 0"/></svg></button>
                    <button id="open-settings" class="btn-icon" title="Settings"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12.22 2h-.44a2 2 0 0 0-2 2v.18a2 2 0 0 1-1 1.73l-.43.25a2 2 0 0 1-2 0l-.15-.08a2 2 0 0 0-2.73.73l-.78 1.28a2 2 0 0 0 .73 2.73l.15.08a2 2 0 0 1 1 1.73v.44a2 2 0 0 0 2 2v.18a2 2 0 0 1 1 1.73l.43.25a2 2 0 0 1 2 0l.15-.08a2 2 0 0 0 2.73.73l.78-1.28a2 2 0 0 0-.73-2.73l-.15-.08a2 2 0 0 1-1-1.73v-.44a2 2 0 0 0 2-2v-.18a2 2 0 0 1 1-1.73l.43-.25a2 2 0 0 1 2 0l.15.08a2 2 0 0 0 2.73-.73l.78-1.28a2 2 0 0 0-.73-2.73l-.15-.08a2 2 0 0 1-1-1.73V4a2 2 0 0 0-2-2z"/><circle cx="12" cy="12" r="3"/></svg></button>
                    <label class="toggle-switch" title="Toggle Dark Mode"><input type="checkbox" id="dark-mode-toggle"><span class="slider"></span></label>
                    <button id="logout-btn" class="btn-secondary py-1 px-3 rounded-lg text-sm">Logout</button>
                </div>
            </div>
            
            <div class="bg-gray-50 p-6 rounded-lg shadow-inner space-y-4">
                <h2 class="text-2xl font-bold text-gray-700 text-center">Set New Alarm</h2>
                <div class="flex items-end gap-2"><div class="flex-1"><label for="alarm-name" class="block text-gray-700 text-sm font-medium mb-1">Alarm Name (optional)</label><input type="text" id="alarm-name" placeholder="Morning meeting, wake up, etc." class="w-full p-3 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-400"></div><button id="generate-name-idea-btn" class="btn-secondary text-sm px-3 py-2 rounded-lg whitespace-nowrap">Idea ✨</button></div>
                <div class="flex items-end gap-2"><div class="flex-1"><label for="alarm-description" class="block text-gray-700 text-sm font-medium mb-1">Description (optional)</label><textarea id="alarm-description" rows="3" placeholder="Details about this alarm or task..." class="w-full p-3 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-400"></textarea></div><button id="enhance-description-btn" class="btn-secondary text-sm px-3 py-2 rounded-lg whitespace-nowrap">Enhance ✨</button></div>
                <div><label for="alarm-address" class="block text-gray-700 text-sm font-medium mb-1">Address (optional for map link)</label><input type="text" id="alarm-address" placeholder="e.g., Eiffel Tower, Paris" class="w-full p-3 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-400"></div>
                <div class="flex flex-col sm:flex-row gap-4"><div class="flex-1"><label for="alarm-date" class="block text-gray-700 text-sm font-medium mb-1">Date</label><input type="date" id="alarm-date" class="w-full p-3 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-400"></div><div class="flex-1"><label for="alarm-time" class="block text-gray-700 text-sm font-medium mb-1">Time</label><input type="time" id="alarm-time" class="w-full p-3 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-400"></div></div>
                <div><label for="recurrence-type" class="block text-gray-700 text-sm font-medium mb-1">Recurrence</label><select id="recurrence-type" class="w-full p-3 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-400"><option value="once">Once</option><option value="daily">Daily</option><option value="weekly">Weekly</option></select></div>
                <div id="weekly-days-container" class="grid grid-cols-3 sm:grid-cols-7 gap-2 hidden"><label class="flex items-center text-gray-700"><input type="checkbox" class="form-checkbox mr-1 weekly-day" value="0"> Sun</label><label class="flex items-center text-gray-700"><input type="checkbox" class="form-checkbox mr-1 weekly-day" value="1"> Mon</label><label class="flex items-center text-gray-700"><input type="checkbox" class="form-checkbox mr-1 weekly-day" value="2"> Tue</label><label class="flex items-center text-gray-700"><input type="checkbox" class="form-checkbox mr-1 weekly-day" value="3"> Wed</label><label class="flex items-center text-gray-700"><input type="checkbox" class="form-checkbox mr-1 weekly-day" value="4"> Thu</label><label class="flex items-center text-gray-700"><input type="checkbox" class="form-checkbox mr-1 weekly-day" value="5"> Fri</label><label class="flex items-center text-gray-700"><input type="checkbox" class="form-checkbox mr-1 weekly-day" value="6"> Sat</label></div>
            </div>

            <div class="bg-gray-50 p-6 rounded-lg shadow-inner space-y-4">
                <h2 class="text-2xl font-bold text-gray-700 text-center mb-4">Upcoming Alarms</h2>
                <div id="alarms-list" class="alarm-list-container h-48 overflow-y-auto pr-2"><p class="text-gray-500 text-center">No alarms set yet.</p></div>
            </div>
        </div>

        <!-- Right Section: Calendar -->
        <div class="flex-1 space-y-6">
            <h2 class="text-3xl font-extrabold text-gray-800 text-center">Calendar</h2>
            <div class="bg-blue-50 p-6 rounded-lg shadow-md">
                <div class="flex justify-between items-center mb-4"><button id="prev-month" class="btn-nav p-2 rounded">&lt; Prev</button><h3 id="calendar-month-year" class="text-xl font-semibold text-blue-700"></h3><button id="next-month" class="btn-nav p-2 rounded">Next &gt;</button></div>
                <div class="grid grid-cols-7 gap-1 text-center text-sm font-medium text-gray-600 mb-2"><div>Sun</div><div>Mon</div><div>Tue</div><div>Wed</div><div>Thu</div><div>Fri</div><div>Sat</div></div>
                <div id="calendar-grid" class="grid grid-cols-7 gap-1"></div>
            </div>
            <div class="bg-blue-50 p-6 rounded-lg shadow-md">
                <h2 class="text-2xl font-bold text-blue-700 text-center mb-4">Alarms for Selected Date</h2>
                <p id="selected-date-display" class="text-gray-600 text-center mb-4 text-lg font-medium">Please select a date on the calendar.</p>
                <div id="selected-day-alarms" class="alarm-list-container h-48 overflow-y-auto pr-2"><p class="text-gray-500 text-center">No alarms for this date.</p></div>
            </div>
        </div>
    </div>

    <!-- Floating Buttons -->
    <button id="set-alarm-btn" class="btn-primary floating-btn hidden">➕ Set Alarm</button>
    <button id="chatbot-btn" class="btn-secondary floating-btn hidden" title="Open Chat Assistant"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-bot"><path d="M12 8V4H8"/><rect width="16" height="12" x="4" y="8" rx="2"/><path d="M2 14h2"/><path d="M20 14h2"/><path d="M15 13v2"/><path d="M9 13v2"/></svg></button>

    <!-- Modals -->
    <div id="custom-modal" class="modal hidden"><div class="modal-content"><h4 id="modal-title" class="text-xl font-bold text-gray-800 mb-3"></h4><p id="modal-message" class="text-gray-700 mb-4"></p><div id="modal-speaker-container"></div><div class="modal-buttons"><button id="modal-confirm-btn" class="btn-primary hidden"></button><button id="modal-cancel-btn" class="btn-secondary hidden"></button><button id="modal-ok-btn" class="btn-primary hidden">OK</button></div></div></div>
    <div id="settings-modal" class="modal hidden"><div class="modal-content"><h4 class="text-xl font-bold text-gray-800 mb-4">Settings</h4><div class="space-y-4 text-left"><div><label for="alarm-sound-select" class="block text-gray-700 text-sm font-medium mb-1">Alarm Sound</label><select id="alarm-sound-select" class="w-full px-2 py-1 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-400 text-sm"></select></div><div><label for="speaker-service-select" class="block text-gray-700 text-sm font-medium mb-1">Speaker Service</label><select id="speaker-service-select" class="w-full px-2 py-1 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-400 text-sm"><option value="browser">Browser TTS</option><option value="openai">OpenAI TTS</option><option value="elevenlabs">ElevenLabs TTS</option></select></div><div><label for="speaker-voice-select" class="block text-gray-700 text-sm font-medium mb-1">Speaker Voice (Browser/OpenAI)</label><select id="speaker-voice-select" class="w-full px-2 py-1 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-400 text-sm"></select></div><div class="flex items-center justify-between"><label for="prioritize-natural-voices-toggle" class="text-gray-700 text-sm font-medium">Prioritize Natural Voices (Browser)</label><label class="toggle-switch"><input type="checkbox" id="prioritize-natural-voices-toggle"><span class="slider"></span></label></div></div><div class="modal-buttons"><button id="save-settings-btn" class="btn-primary">Save</button><button id="cancel-settings-btn" class="btn-secondary">Cancel</button></div></div></div>
    <div id="chatbot-modal" class="modal hidden"><div class="modal-content"><h4 class="text-xl font-bold text-gray-800 mb-4">Chat Assistant</h4><div id="chatbot-messages" class="chatbot-messages"><div class="chat-message bot-message">Hello! How can I help you find your tasks? Try asking "show my alarms for tomorrow" or "what's scheduled for 2025-12-25?".</div></div><div class="flex gap-2 mt-4"><input type="text" id="chatbot-input" class="w-full p-3 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-400" placeholder="Ask about your alarms..."><button id="chatbot-send-btn" class="btn-primary px-4">Send</button></div><button id="chatbot-close-btn" class="btn-secondary mt-4 w-full">Close</button></div></div>
    
    <!-- Login/Register Modals -->
    <div id="login-modal" class="modal"><div class="modal-content"><h4 class="text-xl font-bold text-gray-800 mb-4">Login</h4><input type="email" id="login-email" placeholder="Email" class="w-full p-3 border border-gray-300 rounded-lg mb-3 focus:outline-none focus:ring-2 focus:ring-blue-400"><input type="password" id="login-password" placeholder="Password" class="w-full p-3 border border-gray-300 rounded-lg mb-4 focus:outline-none focus:ring-2 focus:ring-blue-400"><button id="login-btn" class="btn-primary w-full mb-2">Login</button><button id="open-register-modal-btn" class="btn-secondary w-full">Register</button><button id="forgot-password-btn" class="text-blue-600 text-sm mt-3 hover:underline">Forgot Password?</button></div></div>
    <div id="register-modal" class="modal hidden"><div class="modal-content"><h4 class="text-xl font-bold text-gray-800 mb-4">Register</h4><input type="text" id="register-username" placeholder="Username" class="w-full p-3 border border-gray-300 rounded-lg mb-3 focus:outline-none focus:ring-2 focus:ring-blue-400"><input type="email" id="register-email" placeholder="Email" class="w-full p-3 border border-gray-300 rounded-lg mb-3 focus:outline-none focus:ring-2 focus:ring-blue-400"><input type="password" id="register-password" placeholder="Password" class="w-full p-3 border border-gray-300 rounded-lg mb-4 focus:outline-none focus:ring-2 focus:ring-blue-400"><button id="register-btn" class="btn-primary w-full mb-2">Register</button><button id="back-to-login-btn" class="btn-secondary w-full">Back to Login</button></div></div>

    <!-- New Prompt Modal for Forgot Password -->
    <div id="prompt-modal" class="modal hidden">
        <div class="modal-content">
            <h4 id="prompt-modal-title" class="text-xl font-bold text-gray-800 mb-3"></h4>
            <p id="prompt-modal-message" class="text-gray-700 mb-4"></p>
            <input type="email" id="prompt-input-field" class="w-full p-3 border border-gray-300 rounded-lg mb-4 focus:outline-none focus:ring-2 focus:ring-blue-400" placeholder="Enter your email">
            <div class="modal-buttons">
                <button id="prompt-modal-ok-btn" class="btn-primary">Submit</button>
                <button id="prompt-modal-cancel-btn" class="btn-secondary">Cancel</button>
            </div>
        </div>
    </div>


    <audio id="alarm-sound" loop></audio>
    <div id="calendar-tooltip" class="rounded-lg shadow-lg hidden"></div>

    <script>
        // --- Global Variables and DOM Elements ---
        const API_BASE_URL = 'http://localhost:5000/api'; // IMPORTANT: Adjust if your backend is on a different port/host

        const appContainer = document.getElementById('app-container');
        const currentTimeDisplay = document.getElementById('current-time'), currentDateDisplay = document.getElementById('current-date');
        const alarmNameInput = document.getElementById('alarm-name'), generateNameIdeaBtn = document.getElementById('generate-name-idea-btn');
        const alarmDescriptionInput = document.getElementById('alarm-description'), enhanceDescriptionBtn = document.getElementById('enhance-description-btn');
        const alarmAddressInput = document.getElementById('alarm-address'), alarmDateInput = document.getElementById('alarm-date'), alarmTimeInput = document.getElementById('alarm-time');
        const recurrenceTypeSelect = document.getElementById('recurrence-type'), weeklyDaysContainer = document.getElementById('weekly-days-container'), weeklyDayCheckboxes = document.querySelectorAll('.weekly-day');
        const setAlarmButton = document.getElementById('set-alarm-btn'), alarmsList = document.getElementById('alarms-list'), alarmSound = document.getElementById('alarm-sound');
        const requestNotificationPermissionButton = document.getElementById('request-notification-permission'), darkModeToggle = document.getElementById('dark-mode-toggle');
        const calendarMonthYear = document.getElementById('calendar-month-year'), calendarGrid = document.getElementById('calendar-grid'), prevMonthButton = document.getElementById('prev-month'), nextMonthButton = document.getElementById('next-month');
        const selectedDateDisplay = document.getElementById('selected-date-display'), selectedDayAlarmsList = document.getElementById('selected-day-alarms'), calendarTooltip = document.getElementById('calendar-tooltip');
        const customModal = document.getElementById('custom-modal'), modalTitle = document.getElementById('modal-title'), modalMessage = document.getElementById('modal-message');
        const modalConfirmBtn = document.getElementById('modal-confirm-btn'), modalCancelBtn = document.getElementById('modal-cancel-btn'), modalOkBtn = document.getElementById('modal-ok-btn'), modalSpeakerContainer = document.getElementById('modal-speaker-container');
        const settingsModal = document.getElementById('settings-modal'), openSettingsButton = document.getElementById('open-settings'), alarmSoundSelect = document.getElementById('alarm-sound-select');
        const speakerServiceSelect = document.getElementById('speaker-service-select'), speakerVoiceSelect = document.getElementById('speaker-voice-select'), prioritizeNaturalVoicesToggle = document.getElementById('prioritize-natural-voices-toggle'), saveSettingsBtn = document.getElementById('save-settings-btn'), cancelSettingsBtn = document.getElementById('cancel-settings-btn');
        const openChatbotButton = document.getElementById('chatbot-btn'), chatbotModal = document.getElementById('chatbot-modal'), chatbotMessages = document.getElementById('chatbot-messages');
        const chatbotInput = document.getElementById('chatbot-input'), chatbotSendBtn = document.getElementById('chatbot-send-btn'), chatbotCloseBtn = document.getElementById('chatbot-close-btn');
        const logoutButton = document.getElementById('logout-btn');

        // Auth Modals
        const loginModal = document.getElementById('login-modal'), loginEmailInput = document.getElementById('login-email'), loginPasswordInput = document.getElementById('login-password'), loginButton = document.getElementById('login-btn');
        const registerModal = document.getElementById('register-modal'), registerUsernameInput = document.getElementById('register-username'), registerEmailInput = document.getElementById('register-email'), registerPasswordInput = document.getElementById('register-password'), registerButton = document.getElementById('register-btn');
        const openRegisterModalBtn = document.getElementById('open-register-modal-btn'), backToLoginBtn = document.getElementById('back-to-login-btn');
        const forgotPasswordBtn = document.getElementById('forgot-password-btn');

        // Prompt Modal elements
        const promptModal = document.getElementById('prompt-modal');
        const promptModalTitle = document.getElementById('prompt-modal-title');
        const promptModalMessage = document.getElementById('prompt-modal-message');
        const promptInputField = document.getElementById('prompt-input-field');
        const promptModalOkBtn = document.getElementById('prompt-modal-ok-btn');
        const promptModalCancelBtn = document.getElementById('prompt-modal-cancel-btn');


        const ALARM_SOUND_OPTIONS = [{ name: "Default (Song 1)", url: "https://www.soundhelix.com/examples/mp3/SoundHelix-Song-1.mp3" }, { name: "Chime", url: "https://www.soundhelix.com/examples/mp3/SoundHelix-Song-2.mp3" }, { name: "Alert Tone", url: "https://www.soundhelix.com/examples/mp3/SoundHelix-Song-3.mp3" }];
        let alarms = [], currentCalendarDate = new Date(), selectedCalendarDay = null, activeAlarmId = null;
        let isSpeechPaused = false, currentUtterance = null, speakingAlarmId = null;
        let selectedSpeechService = 'browser'; // Default speech service
        let selectedBrowserVoice = null; // For browser TTS


        // --- Authentication Functions ---

        /**
         * Makes an authenticated fetch request to the backend.
         * @param {string} url - The API endpoint.
         * @param {object} options - Fetch options (method, headers, body).
         * @returns {Promise<Response>} The fetch response.
         */
        async function makeAuthenticatedRequest(url, options = {}) {
            const token = sessionStorage.getItem('jwtToken');
            const headers = {
                'Content-Type': 'application/json',
                ...options.headers,
            };
            if (token) {
                headers['Authorization'] = `Bearer ${token}`;
            }

            const response = await fetch(`${API_BASE_URL}${url}`, {
                ...options,
                headers,
            });

            if (response.status === 401) {
                // Token expired or invalid, force logout
                logoutUser();
                showAlert('Session Expired', 'Your session has expired. Please log in again.');
            }

            return response;
        }

        /**
         * Handles user login.
         */
        async function loginUser() {
            const email = loginEmailInput.value;
            const password = loginPasswordInput.value;

            if (!email || !password) {
                return showAlert('Input Error', 'Please enter both email and password.');
            }

            try {
                const response = await fetch(`${API_BASE_URL}/auth/login`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ email, password })
                });
                const data = await response.json();

                if (response.ok) {
                    sessionStorage.setItem('jwtToken', data.token);
                    sessionStorage.setItem('username', data.username);
                    loginModal.classList.add('hidden');
                    showAlert('Success', `Welcome, ${data.username}!`);
                    checkAuthAndRender(); // Render app content
                } else {
                    showAlert('Login Failed', data.message || 'Invalid credentials.');
                }
            } catch (error) {
                console.error('Login error:', error);
                showAlert('Error', 'Could not connect to the server.');
            }
        }

        /**
         * Handles user registration.
         */
        async function registerUser() {
            const username = registerUsernameInput.value;
            const email = registerEmailInput.value;
            const password = registerPasswordInput.value;

            if (!username || !email || !password) {
                return showAlert('Input Error', 'Please fill in all fields.');
            }

            try {
                const response = await fetch(`${API_BASE_URL}/auth/register`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ username, email, password })
                });
                const data = await response.json();

                if (response.ok) {
                    sessionStorage.setItem('jwtToken', data.token);
                    sessionStorage.setItem('username', data.username);
                    registerModal.classList.add('hidden');
                    showAlert('Success', `Account created for ${data.username}! You are now logged in.`);
                    checkAuthAndRender(); // Render app content
                } else {
                    showAlert('Registration Failed', data.message || 'Error creating account.');
                }
            } catch (error) {
                console.error('Registration error:', error);
                showAlert('Error', 'Could not connect to the server.');
            }
        }

        /**
         * Handles user logout.
         */
        function logoutUser() {
            sessionStorage.removeItem('jwtToken');
            sessionStorage.removeItem('username');
            appContainer.classList.add('hidden');
            setAlarmButton.classList.add('hidden');
            openChatbotButton.classList.add('hidden'); // Fix: changed chatbotButton to openChatbotButton
            loginModal.classList.remove('hidden');
            showAlert('Logged Out', 'You have been successfully logged out.');
        }

        /**
         * Checks authentication status and renders the appropriate UI.
         */
        async function checkAuthAndRender() {
            const token = sessionStorage.getItem('jwtToken');
            if (token) {
                // Attempt to fetch alarms to validate token (optional, but good for UX)
                try {
                    const response = await makeAuthenticatedRequest('/alarms');
                    if (response.ok) {
                        alarms = await response.json(); // Load alarms from DB
                        appContainer.classList.remove('hidden');
                        setAlarmButton.classList.remove('hidden');
                        openChatbotButton.classList.remove('hidden');
                        loginModal.classList.add('hidden');
                        renderAlarms();
                        renderCalendar(currentCalendarDate.getFullYear(), currentCalendarDate.getMonth());
                    } else {
                        // Token might be invalid or expired, proceed to login
                        logoutUser();
                    }
                } catch (error) {
                    console.error('Failed to validate token or fetch alarms:', error);
                    logoutUser();
                    showAlert('Server Error', 'Could not connect to the alarm server. Please try again.');
                }
            } else {
                loginModal.classList.remove('hidden');
                appContainer.classList.add('hidden');
                setAlarmButton.classList.add('hidden');
                openChatbotButton.classList.add('hidden');
            }
        }

        // --- TTS with Pause/Resume ---

        /**
         * Updates the icon and title of a speaker button based on the current speech state.
         * @param {HTMLElement} button - The speaker button element.
         * @param {string} alarmId - The ID of the alarm associated with the button.
         */
        function updateSpeakerButtonIcon(button, alarmId) {
            if (speakingAlarmId === alarmId && (speechSynthesis.speaking || alarmSound.duration > 0 && !alarmSound.paused)) {
                button.innerHTML = isSpeechPaused
                    ? `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="5 3 19 12 5 21 5 3"/></svg>` // Play icon
                    : `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="6" y="4" width="4" height="16"/><rect x="14" y="4" width="4" height="16"/></svg>`; // Pause icon
                button.title = isSpeechPaused ? "Resume Speech" : "Pause Speech";
            } else {
                button.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"/><path d="M19.07 4.93a10 10 0 0 1 0 14.14M15.54 8.46a5 5 0 0 1 0 7.07"/></svg>`; // Speaker icon
                button.title = "Speak Alarm Details";
            }
        }

        /**
         * Handles the click event for a speaker button, toggling speech play/pause.
         * @param {object} alarm - The alarm object to speak about.
         */
        async function handleSpeakButtonClick(alarm) {
            const currentService = speakerServiceSelect.value;
            const textToSpeak = generateSpeechText(alarm);

            if (currentService === 'browser') {
                if (!('speechSynthesis' in window)) {
                    return showAlert('Feature Not Supported', 'Browser text-to-speech is not supported.');
                }
                if (speechSynthesis.speaking && speakingAlarmId === alarm._id) {
                    if (isSpeechPaused) {
                        speechSynthesis.resume();
                    } else {
                        speechSynthesis.pause();
                    }
                } else {
                    speechSynthesis.cancel();
                    currentUtterance = new SpeechSynthesisUtterance(textToSpeak);
                    if(selectedBrowserVoice) currentUtterance.voice = selectedBrowserVoice;
                    currentUtterance.onstart = () => { isSpeechPaused = false; speakingAlarmId = alarm._id; updateAllSpeakerButtons(); };
                    currentUtterance.onpause = () => { isSpeechPaused = true; updateAllSpeakerButtons(); };
                    currentUtterance.onresume = () => { isSpeechPaused = false; updateAllSpeakerButtons(); };
                    currentUtterance.onend = () => { speakingAlarmId = null; isSpeechPaused = false; currentUtterance = null; updateAllSpeakerButtons(); };
                    currentUtterance.onerror = (event) => { console.error("SpeechSynthesisUtterance.onerror", event); speakingAlarmId = null; isSpeechPaused = false; showAlert('Speech Error', 'Could not play audio.'); updateAllSpeakerButtons(); };
                    speechSynthesis.speak(currentUtterance);
                }
            } else { // OpenAI or ElevenLabs
                if (alarmSound.duration > 0 && !alarmSound.paused && speakingAlarmId === alarm._id) {
                    if (alarmSound.paused) {
                        alarmSound.play();
                    } else {
                        alarmSound.pause();
                    }
                    isSpeechPaused = alarmSound.paused;
                    updateAllSpeakerButtons();
                } else {
                    // Cancel any ongoing speech first
                    if (speechSynthesis.speaking) speechSynthesis.cancel();
                    if (!alarmSound.paused) { alarmSound.pause(); alarmSound.currentTime = 0; }

                    speakingAlarmId = alarm._id; // Mark current alarm as speaking
                    isSpeechPaused = false; // Reset pause state
                    updateAllSpeakerButtons(); // Update button to reflect playing state

                    try {
                        const endpoint = currentService === 'openai' ? '/speech/generate-openai' : '/speech/generate-elevenlabs';
                        const voiceParam = currentService === 'openai' ? { voice: speakerVoiceSelect.value || "alloy" } : { voiceId: speakerVoiceSelect.value || "21m00TzPtLmVvB9WbCUs" }; // Default Voice ID for 'Rachel'

                        const response = await makeAuthenticatedRequest(endpoint, {
                            method: 'POST',
                            body: JSON.stringify({ text: textToSpeak, ...voiceParam })
                        });

                        if (!response.ok) {
                            throw new Error(`Failed to generate speech: ${response.statusText}`);
                        }

                        const audioBlob = await response.blob();
                        const audioUrl = URL.createObjectURL(audioBlob);

                        alarmSound.src = audioUrl;
                        alarmSound.loop = false; // Speech should not loop
                        await alarmSound.play();

                        alarmSound.onended = () => {
                            speakingAlarmId = null;
                            updateAllSpeakerButtons();
                            URL.revokeObjectURL(audioUrl); // Clean up the Blob URL
                        };
                        alarmSound.onpause = () => { isSpeechPaused = true; updateAllSpeakerButtons(); };
                        alarmSound.onplay = () => { isSpeechPaused = false; updateAllSpeakerButtons(); };

                    } catch (error) {
                        console.error(`AI TTS Error (${currentService}):`, error);
                        showAlert('Speech Error', `Could not generate speech with ${currentService}. Error: ${error.message}`);
                        speakingAlarmId = null;
                        updateAllSpeakerButtons();
                        if (!alarmSound.paused) { alarmSound.pause(); alarmSound.currentTime = 0; } // Ensure sound stops
                    }
                }
            }
        }


        /**
         * Generates the text string for speech synthesis from an alarm object.
         * @param {object} alarm - The alarm object.
         * @returns {string} The formatted text for speech.
         */
        function generateSpeechText(alarm) {
            let speechText = `Alarm details: ${alarm.name || 'Untitled Alarm'}. `;
            if (alarm.description) speechText += `${alarm.description}. `;
            
            if(alarm.recurrenceType === 'daily') speechText += 'This alarm repeats daily. ';
            else if (alarm.recurrenceType === 'weekly' && alarm.recurrenceDays.length > 0) {
                speechText += `It repeats weekly on ${alarm.recurrenceDays.map(d=>['Sunday','Monday','Tuesday','Wednesday','Thursday','Friday','Saturday'][d]).join(', ')}. `;
            }
            if(alarm.address) speechText += `Location is ${alarm.address}.`;
            return speechText;
        }

        /**
         * Updates the icons of all speaker buttons on the page.
         */
        function updateAllSpeakerButtons() {
            document.querySelectorAll('.speaker-btn-small, .modal-speaker-btn').forEach(btn => {
                const alarmId = btn.dataset.alarmId; // Use string ID from MongoDB
                updateSpeakerButtonIcon(btn, alarmId);
            });
        }

        /**
         * Creates a speaker button element.
         * @param {object} alarm - The alarm object associated with the button.
         * @param {boolean} isModal - True if the button is for a modal, false otherwise.
         * @returns {HTMLElement} The created button element.
         */
        function createSpeakerButton(alarm, isModal = false) {
            const speakerButton = document.createElement('button');
            speakerButton.className = isModal ? 'btn-secondary modal-speaker-btn text-sm py-1 px-3 mt-4 mx-auto' : 'speaker-btn-small';
            speakerButton.dataset.alarmId = alarm._id; // Use MongoDB _id
            updateSpeakerButtonIcon(speakerButton, alarm._id); // Set initial icon
            speakerButton.onclick = (e) => { e.stopPropagation(); handleSpeakButtonClick(alarm); };
            return speakerButton;
        }

        // --- Modals and Utility Functions ---
        /**
         * Displays a custom alert modal.
         * @param {string} title - The title of the alert.
         * @param {string} message - The message content.
         * @param {object} [alarmObject=null] - Optional alarm object for speaking.
         */
        function showAlert(title, message, alarmObject = null) {
            modalTitle.textContent = title;
            modalMessage.textContent = message;
            modalSpeakerContainer.innerHTML = '';
            if (alarmObject && (alarmObject.name || alarmObject.description || alarmObject.address)) {
                const speakBtn = createSpeakerButton(alarmObject, true);
                modalSpeakerContainer.appendChild(speakBtn);
            }
            modalConfirmBtn.classList.add('hidden');
            modalCancelBtn.classList.add('hidden');
            modalOkBtn.classList.remove('hidden');
            customModal.classList.remove('hidden');
            modalOkBtn.onclick = () => {
                customModal.classList.add('hidden');
                if (speechSynthesis.speaking && speakingAlarmId === (alarmObject ? alarmObject._id : null)) {
                    speechSynthesis.cancel();
                }
                if (alarmSound.duration > 0 && !alarmSound.paused && speakingAlarmId === (alarmObject ? alarmObject._id : null)) {
                    alarmSound.pause();
                    alarmSound.currentTime = 0;
                }
                speakingAlarmId = null; // Reset speaking alarm ID
                updateAllSpeakerButtons(); // Update icons
            };
        }

        /**
         * Displays a custom confirmation modal.
         * @param {string} title - The title of the confirmation.
         * @param {string} message - The message content.
         * @returns {Promise<boolean>} A promise that resolves to true if confirmed, false if canceled.
         */
        function showConfirm(title, message) {
            return new Promise(resolve => {
                modalTitle.textContent = title;
                modalMessage.textContent = message;
                modalConfirmBtn.textContent = 'Confirm';
                modalCancelBtn.textContent = 'Cancel';
                modalConfirmBtn.classList.remove('hidden');
                modalCancelBtn.classList.remove('hidden');
                modalOkBtn.classList.add('hidden');
                modalSpeakerContainer.innerHTML = ''; // Clear speaker button for confirm
                customModal.classList.remove('hidden');
                modalConfirmBtn.onclick = () => {
                    customModal.classList.add('hidden');
                    resolve(true);
                };
                modalCancelBtn.onclick = () => {
                    customModal.classList.add('hidden');
                    resolve(false);
                };
            });
        }

        /**
         * Displays a custom prompt modal with an input field.
         * @param {string} title - The title of the prompt.
         * @param {string} message - The message/instruction for the input.
         * @param {string} inputType - The type of the input field (e.g., 'text', 'email', 'password').
         * @param {string} placeholder - The placeholder text for the input field.
         * @returns {Promise<string|null>} A promise that resolves with the user's input string, or null if canceled.
         */
        function showPromptModal(title, message, inputType = 'text', placeholder = '') {
            return new Promise(resolve => {
                promptModalTitle.textContent = title;
                promptModalMessage.textContent = message;
                promptInputField.type = inputType;
                promptInputField.placeholder = placeholder;
                promptInputField.value = ''; // Clear previous input
                
                promptModal.classList.remove('hidden');

                const onSubmit = () => {
                    promptModal.classList.add('hidden');
                    resolve(promptInputField.value);
                    promptModalOkBtn.removeEventListener('click', onSubmit);
                    promptModalCancelBtn.removeEventListener('click', onCancel);
                };

                const onCancel = () => {
                    promptModal.classList.add('hidden');
                    resolve(null);
                    promptModalOkBtn.removeEventListener('click', onSubmit);
                    promptModalCancelBtn.removeEventListener('click', onCancel);
                };

                promptModalOkBtn.addEventListener('click', onSubmit);
                promptModalCancelBtn.addEventListener('click', onCancel);
            });
        }


        /**
         * Formats a Date object into a readable date string.
         * @param {Date} date - The date to format.
         * @returns {string} The formatted date string.
         */
        function formatDate(date) {
            return new Date(date).toLocaleDateString(undefined, { year: 'numeric', month: 'long', day: 'numeric' });
        }

        /**
         * Formats a Date object into a readable time string.
         * @param {Date} date - The date to format.
         * @returns {string} The formatted time string.
         */
        function formatTime(date) {
            // Assumes input 'date' is a string in "HH:MM" format
            const [hours, minutes] = date.split(':');
            const dummyDate = new Date(); // Use a dummy date to construct time object
            dummyDate.setHours(parseInt(hours), parseInt(minutes), 0, 0);
            return dummyDate.toLocaleTimeString(undefined, { hour: '2-digit', minute: '2-digit', hour12: true });
        }


        /**
         * Generates a Google Maps search link for a given address.
         * @param {string} address - The address to search for.
         * @returns {string} The Google Maps URL.
         */
        function generateGoogleMapsLink(address) {
            return address ? `https://www.google.com/maps/search/?api=1&query=${encodeURIComponent(address)}` : '';
        }

        /**
         * Updates the current time and date display on the UI.
         */
        function updateCurrentTimeDisplay() {
            const now = new Date();
            currentTimeDisplay.textContent = now.toLocaleTimeString(undefined, { hour: '2-digit', minute: '2-digit', second: '2-digit', hour12: true });
            currentDateDisplay.textContent = now.toLocaleDateString(undefined, { year: 'numeric', month: 'long', day: 'numeric' });
        }

        /**
         * Sets the default date and time values for the alarm input fields to the current date and time.
         */
        function setDefaultAlarmDateTime() {
            const now = new Date();
            const year = now.getFullYear();
            const month = (now.getMonth() + 1).toString().padStart(2, '0');
            const day = now.getDate().toString().padStart(2, '0');
            const hours = now.getHours().toString().padStart(2, '0');
            const minutes = now.getMinutes().toString().padStart(2, '0');

            alarmDateInput.value = `${year}-${month}-${day}`;
            alarmTimeInput.value = `${hours}:${minutes}`;
        }

        // --- Alarm Core Logic ---
        /**
         * Checks all active alarms against the current time and triggers them if due.
         */
        async function checkAlarms() {
            const now = new Date();
            const currentHour = now.getHours();
            const currentMinute = now.getMinutes();
            const currentSecond = now.getSeconds();
            const todayISO = now.toISOString().split('T')[0];

            for (const alarm of alarms) {
                const alarmTimeParts = alarm.time.split(':').map(Number);
                const alarmHour = alarmTimeParts[0];
                const alarmMinute = alarmTimeParts[1];

                if (alarm.recurrenceType === 'once') {
                    const alarmDateTime = new Date(`${alarm.date}T${alarm.time}:00`);
                    if (alarmDateTime.getFullYear() === now.getFullYear() &&
                        alarmDateTime.getMonth() === now.getMonth() &&
                        alarmDateTime.getDate() === now.getDate() &&
                        alarmHour === currentHour &&
                        alarmMinute === currentMinute &&
                        currentSecond === 0 &&
                        !alarm.isTriggered) {
                        triggerAlarm(alarm);
                        // Update alarm in DB
                        alarm.isTriggered = true;
                        await updateAlarmInDb(alarm);
                        renderAlarms(); // Re-render to show struck-through
                        renderCalendar(currentCalendarDate.getFullYear(), currentCalendarDate.getMonth()); // Update calendar if needed
                    }
                } else { // Daily or Weekly recurrence
                    const isTodayDue = alarm.recurrenceType === 'daily' ||
                                      (alarm.recurrenceType === 'weekly' && alarm.recurrenceDays.includes(now.getDay()));

                    // Reset triggeredForToday at the start of a new day
                    if (alarm.lastCheckedDate !== todayISO && isTodayDue) { // Only reset if it's a new day and relevant for recurrence
                        alarm.triggeredForToday = false;
                        alarm.lastCheckedDate = todayISO;
                        await updateAlarmInDb(alarm); // Update in DB
                    }

                    if (isTodayDue &&
                        alarmHour === currentHour &&
                        alarmMinute === currentMinute &&
                        currentSecond === 0 &&
                        !alarm.triggeredForToday) {
                        triggerAlarm(alarm);
                        alarm.triggeredForToday = true;
                        await updateAlarmInDb(alarm); // Update in DB
                        renderAlarms(); // Re-render for active state
                    }
                }
            }
        }

        /**
         * Triggers an alarm, plays sound, shows notification, and displays an alert modal.
         * @param {object} alarm - The alarm object to trigger.
         */
        function triggerAlarm(alarm) {
            const alarmMessage = `${alarm.name || 'Your alarm'} is going off!`;
            if (Notification.permission === 'granted') {
                new Notification('Alarm!', { body: alarmMessage, icon: 'https://placehold.co/128x128/007bff/ffffff?text=🔔' });
            }
            showAlert('Alarm!', alarmMessage, alarm);
            try {
                alarmSound.play();
                activeAlarmId = alarm._id; // Use _id from MongoDB
                renderAlarms(); // Re-render to show red text
            } catch (error) {
                console.error("Error playing sound:", error);
            }
        }

        /**
         * Renders the list of alarms in the specified container.
         * @param {Array<object>} [filteredAlarms=alarms] - Optional array of alarms to render.
         * @param {HTMLElement} [targetList=alarmsList] - The DOM element where alarms should be rendered.
         */
        function renderAlarms(filteredAlarms = alarms, targetList = alarmsList) {
            targetList.innerHTML = '';
            if (filteredAlarms.length === 0) {
                targetList.innerHTML = '<p class="text-gray-500 text-center">No alarms set yet.</p>';
                return;
            }

            const sortedAlarms = [...filteredAlarms].sort((a, b) => {
                const [hA, mA] = a.time.split(':').map(Number);
                const [hB, mB] = b.time.split(':').map(Number);
                if (hA !== hB) return hA - hB;
                return mA - mB;
            });

            sortedAlarms.forEach(alarm => {
                const li = document.createElement('li');
                li.className = 'flex flex-col bg-white p-3 rounded-md shadow-sm mb-2';

                const mainInfoDiv = document.createElement('div');
                mainInfoDiv.className = 'flex items-center justify-between';

                const alarmText = document.createElement('span');
                alarmText.className = 'text-base font-semibold';
                let displayText = `⏰ ${alarm.name || 'Alarm'} at ${formatTime(alarm.time)}`; // Use formatTime here
                if (alarm.recurrenceType === 'once') {
                    displayText += ` on ${formatDate(alarm.date)}`;
                } else if (alarm.recurrenceType === 'weekly') {
                    const days = alarm.recurrenceDays.map(d => ['Sun','Mon','Tue','Wed','Thu','Fri','Sat'][d]).join(', ');
                    displayText += ` (Weekly on ${days})`;
                } else {
                    displayText += ` (${alarm.recurrenceType})`;
                }
                alarmText.textContent = displayText;

                // Apply styles based on alarm state
                if (activeAlarmId === alarm._id) { // Use _id for comparison
                    alarmText.classList.add('text-red-600');
                    alarmText.classList.remove('strike-blue');
                } else if (alarm.recurrenceType === 'once' && alarm.isTriggered) { // Once-off alarm completed
                    alarmText.classList.add('strike-blue');
                    alarmText.classList.remove('text-red-600');
                    alarmText.classList.add('text-gray-800');
                } else if (alarm.recurrenceType !== 'once' && alarm.triggeredForToday) { // Recurring alarm done for today
                    alarmText.classList.add('strike-blue');
                    alarmText.classList.remove('text-red-600');
                    alarmText.classList.add('text-gray-800');
                } else { // Default state
                    alarmText.classList.remove('text-red-600');
                    alarmText.classList.remove('strike-blue');
                    alarmText.classList.add('text-gray-800');
                }

                const buttonContainer = document.createElement('div');
                buttonContainer.className = 'flex items-center';

                if (activeAlarmId === alarm._id) {
                    const stopButton = document.createElement('button');
                    stopButton.textContent = 'Stop';
                    stopButton.className = 'btn-danger mr-2';
                    stopButton.onclick = async () => {
                        alarmSound.pause();
                        alarmSound.currentTime = 0;
                        activeAlarmId = null;
                        // For 'once' alarms, mark as triggered when stopped
                        if (alarm.recurrenceType === 'once') {
                            const alarmToUpdate = alarms.find(a => a._id === alarm._id);
                            if (alarmToUpdate) alarmToUpdate.isTriggered = true;
                        }
                        // For recurring alarms, if stopped, assume 'triggered for today' to prevent immediate re-trigger
                        if (alarm.recurrenceType !== 'once') {
                             const alarmToUpdate = alarms.find(a => a._id === alarm._id);
                             if (alarmToUpdate) alarmToUpdate.triggeredForToday = true;
                        }
                        await updateAlarmInDb(alarm); // Persist state change
                        renderAlarms(); // Re-render both lists
                        displayAlarmsForSelectedDay(currentCalendarDate.getDate(), currentCalendarDate.getMonth(), currentCalendarDate.getFullYear());
                        updateAllSpeakerButtons();
                    };
                    buttonContainer.appendChild(stopButton);
                }

                const deleteButton = document.createElement('button');
                deleteButton.textContent = 'Delete';
                deleteButton.className = 'btn-danger';
                deleteButton.onclick = async () => {
                    if (await showConfirm('Delete Alarm?', `Are you sure you want to delete "${alarm.name || 'Untitled'}"?`)) {
                        await deleteAlarmFromDb(alarm._id);
                        alarms = alarms.filter(a => a._id !== alarm._id); // Update local array
                        if (activeAlarmId === alarm._id) {
                            if (speechSynthesis.speaking) speechSynthesis.cancel();
                            if (alarmSound.duration > 0 && !alarmSound.paused) {
                                alarmSound.pause();
                                alarmSound.currentTime = 0;
                            }
                            activeAlarmId = null;
                        }
                        renderAlarms();
                        renderCalendar(currentCalendarDate.getFullYear(), currentCalendarDate.getMonth());
                        displayAlarmsForSelectedDay(currentCalendarDate.getDate(), currentCalendarDate.getMonth(), currentCalendarDate.getFullYear()); // Update selected day alarms list
                        updateAllSpeakerButtons();
                    }
                };
                buttonContainer.appendChild(deleteButton);

                mainInfoDiv.appendChild(alarmText);
                mainInfoDiv.appendChild(buttonContainer);
                li.appendChild(mainInfoDiv);

                const detailsDiv = document.createElement('div');
                detailsDiv.className = 'text-gray-600 text-sm mt-1 flex items-center justify-between';
                
                const textDetailsSpan = document.createElement('span');
                textDetailsSpan.className = 'flex-1';
                if (alarm.description) {
                    textDetailsSpan.textContent = alarm.description;
                }
                if (alarm.address) {
                    const mapLink = document.createElement('a');
                    mapLink.href = alarm.mapLink;
                    mapLink.target = '_blank';
                    mapLink.className = 'text-blue-500 hover:underline ml-2';
                    mapLink.textContent = `📍 View Map`;
                    textDetailsSpan.appendChild(mapLink);
                }
                detailsDiv.appendChild(textDetailsSpan);
                detailsDiv.appendChild(createSpeakerButton(alarm));
                li.appendChild(detailsDiv);

                targetList.appendChild(li);
            });
            updateAllSpeakerButtons();
        }


        setAlarmButton.addEventListener('click', async () => {
            const recurrenceType = recurrenceTypeSelect.value;
            let recurrenceDays = [];

            if (!alarmTimeInput.value || (recurrenceType === 'once' && !alarmDateInput.value)) {
                return showAlert('Input Error', 'Please select a date and time for the alarm.');
            }

            if (recurrenceType === 'once') {
                const alarmDateTime = new Date(`${alarmDateInput.value}T${alarmTimeInput.value}`);
                if (alarmDateTime <= new Date()) {
                    return showAlert('Invalid Time', 'Please select a future date and time.');
                }
            }

            if (recurrenceType === 'weekly') {
                weeklyDayCheckboxes.forEach(cb => {
                    if(cb.checked) recurrenceDays.push(parseInt(cb.value));
                });
                if (recurrenceDays.length === 0) {
                    return showAlert('Input Error', 'Please select at least one day for weekly recurrence.');
                }
            }

            const newAlarm = {
                date: alarmDateInput.value,
                time: alarmTimeInput.value,
                name: alarmNameInput.value.trim() || 'Untitled Alarm',
                description: alarmDescriptionInput.value.trim(),
                address: alarmAddressInput.value.trim(),
                recurrenceType,
                recurrenceDays,
            };

            const savedAlarm = await saveAlarmToDb(newAlarm);
            if (savedAlarm) {
                alarms.push(savedAlarm); // Add the returned alarm (with _id)
                renderAlarms();
                renderCalendar(currentCalendarDate.getFullYear(), currentCalendarDate.getMonth());
                showAlert('Success', `Alarm "${savedAlarm.name}" set successfully.`, savedAlarm);

                // Reset form fields
                alarmNameInput.value = '';
                alarmDescriptionInput.value = '';
                alarmAddressInput.value = '';
                setDefaultAlarmDateTime();
                recurrenceTypeSelect.value = 'once';
                weeklyDaysContainer.classList.add('hidden');
                alarmDateInput.disabled = false;
                weeklyDayCheckboxes.forEach(cb => cb.checked = false);
            }
        });

        /**
         * Saves a new alarm to the backend database.
         * @param {object} alarmData - The alarm data to save.
         * @returns {Promise<object|null>} The saved alarm object from the DB, or null on error.
         */
        async function saveAlarmToDb(alarmData) {
            try {
                const response = await makeAuthenticatedRequest('/alarms', {
                    method: 'POST',
                    body: JSON.stringify(alarmData)
                });
                if (response.ok) {
                    return await response.json();
                } else {
                    const errorData = await response.json();
                    showAlert('Error Saving Alarm', errorData.message || 'Failed to save alarm.');
                    return null;
                }
            } catch (error) {
                console.error('Error saving alarm to DB:', error);
                showAlert('Network Error', 'Could not connect to the server to save alarm.');
                return null;
            }
        }

        /**
         * Updates an existing alarm in the backend database.
         * @param {object} alarm - The alarm object to update (must contain _id).
         * @returns {Promise<object|null>} The updated alarm object from the DB, or null on error.
         */
        async function updateAlarmInDb(alarm) {
            try {
                const response = await makeAuthenticatedRequest(`/alarms/${alarm._id}`, {
                    method: 'PUT',
                    body: JSON.stringify(alarm)
                });
                if (response.ok) {
                    return await response.json();
                } else {
                    const errorData = await response.json();
                    showAlert('Error Updating Alarm', errorData.message || 'Failed to update alarm.');
                    return null;
                }
            } catch (error) {
                console.error('Error updating alarm in DB:', error);
                showAlert('Network Error', 'Could not connect to the server to update alarm.');
                return null;
            }
        }

        /**
         * Deletes an alarm from the backend database.
         * @param {string} alarmId - The ID of the alarm to delete.
         * @returns {Promise<boolean>} True if deleted successfully, false otherwise.
         */
        async function deleteAlarmFromDb(alarmId) {
            try {
                const response = await makeAuthenticatedRequest(`/alarms/${alarmId}`, {
                    method: 'DELETE'
                });
                if (response.ok) {
                    return true;
                } else {
                    const errorData = await response.json();
                    showAlert('Error Deleting Alarm', errorData.message || 'Failed to delete alarm.');
                    return false;
                }
            } catch (error) {
                console.error('Error deleting alarm from DB:', error);
                showAlert('Network Error', 'Could not connect to the server to delete alarm.');
                return false;
            }
        }


        recurrenceTypeSelect.addEventListener('change', () => {
            weeklyDaysContainer.classList.toggle('hidden', recurrenceTypeSelect.value !== 'weekly');
            alarmDateInput.disabled = recurrenceTypeSelect.value !== 'once';
        });

        // --- Calendar Logic ---
        /**
         * Renders the calendar grid for the specified year and month.
         * @param {number} year - The year to display.
         * @param {number} month - The month to display (0-indexed).
         */
        function renderCalendar(year, month) {
            calendarGrid.innerHTML = '';
            const firstDayOfMonth = new Date(year, month, 1);
            const daysInMonth = new Date(year, month + 1, 0).getDate();
            const startingDayOfWeek = firstDayOfMonth.getDay(); // 0 for Sunday, 6 for Saturday

            calendarMonthYear.textContent = firstDayOfMonth.toLocaleDateString('en-US', { month: 'long', year: 'numeric' });

            // Add empty divs for days before the first day of the month
            for (let i = 0; i < startingDayOfWeek; i++) {
                const emptyDiv = document.createElement('div');
                calendarGrid.appendChild(emptyDiv);
            }

            for (let day = 1; day <= daysInMonth; day++) {
                const dayDiv = document.createElement('div');
                dayDiv.className = 'calendar-day p-3 text-center rounded-lg cursor-pointer transition-all duration-200';
                dayDiv.textContent = day;
                dayDiv.dataset.day = day;

                const isToday = new Date().getDate() === day && new Date().getMonth() === month && new Date().getFullYear() === year;
                if(isToday) {
                    dayDiv.classList.add('current-day');
                }

                const alarmsOnDay = getAlarmsForDate(day, month, year);
                if(alarmsOnDay.length > 0) {
                    dayDiv.classList.add('has-alarm');
                    // Add tooltip event listeners
                    addTooltipListeners(dayDiv, alarmsOnDay);
                }

                dayDiv.addEventListener('click', () => {
                    // Remove selected-day class from previously selected day
                    if(selectedCalendarDay) {
                        selectedCalendarDay.classList.remove('selected-day');
                    }
                    dayDiv.classList.add('selected-day');
                    selectedCalendarDay = dayDiv;
                    displayAlarmsForSelectedDay(day, month, year);
                });

                calendarGrid.appendChild(dayDiv);
            }
        }

        /**
         * Adds mouse event listeners to a calendar day element for displaying tooltips.
         * @param {HTMLElement} dayDiv - The calendar day div element.
         * @param {Array<object>} alarmsForDay - An array of alarm objects for that day.
         */
        function addTooltipListeners(dayDiv, alarmsForDay) {
            dayDiv.addEventListener('mouseenter', (e) => {
                if (alarmsForDay.length === 0) return;

                let tooltipContent = '<ul>';
                alarmsForDay.forEach(alarm => {
                    tooltipContent += `<li><strong>${formatTime(alarm.time)}</strong>: ${alarm.name || 'Untitled Alarm'}`;
                    if (alarm.description) {
                        tooltipContent += `<br>${alarm.description}`;
                    }
                    tooltipContent += '</li>';
                });
                tooltipContent += '</ul>';

                calendarTooltip.innerHTML = tooltipContent;
                calendarTooltip.classList.remove('hidden');

                // Position the tooltip
                const rect = dayDiv.getBoundingClientRect();
                calendarTooltip.style.left = `${rect.left + window.scrollX + rect.width / 2 - calendarTooltip.offsetWidth / 2}px`;
                calendarTooltip.style.top = `${rect.top + window.scrollY - calendarTooltip.offsetHeight - 10}px`; // 10px above the element
                calendarTooltip.style.opacity = '1';
                calendarTooltip.style.transform = 'translateY(0)';
            });

            dayDiv.addEventListener('mouseleave', () => {
                calendarTooltip.style.opacity = '0';
                calendarTooltip.style.transform = 'translateY(-10px)';
                setTimeout(() => {
                    calendarTooltip.classList.add('hidden');
                }, 200); // Hide after transition
            });
        }


        /**
         * Retrieves alarms that fall on a specific date, considering recurrence.
         * @param {number} day - The day of the month.
         * @param {number} month - The month (0-indexed).
         * @param {number} year - The year.
         * @returns {Array<object>} An array of alarm objects for the specified date.
         */
        function getAlarmsForDate(day, month, year) {
            const checkDate = new Date(year, month, day);
            const checkDateISO = checkDate.toISOString().split('T')[0]; // Format to INSEE-MM-DD for comparison

            return alarms.filter(alarm => {
                if (alarm.recurrenceType === 'once') {
                    return alarm.date === checkDateISO; // Direct string comparison
                }
                if (alarm.recurrenceType === 'daily') {
                    // For daily alarms, check if their set date is on or before the checkDate
                    return alarm.date <= checkDateISO;
                }
                if (alarm.recurrenceType === 'weekly') {
                     return alarm.date <= checkDateISO && alarm.recurrenceDays.includes(checkDate.getDay());
                }
                return false;
            });
        }

        /**
         * Displays alarms for the selected calendar day in the dedicated section.
         * @param {number} day - The day of the month.
         * @param {number} month - The month (0-indexed).
         * @param {number} year - The year.
         */
        function displayAlarmsForSelectedDay(day, month, year) {
            selectedDayAlarmsList.innerHTML = '';
            const selectedDate = new Date(year, month, day);
            selectedDateDisplay.textContent = `Alarms for: ${formatDate(selectedDate)}`;

            const alarmsForDay = getAlarmsForDate(day, month, year);

            if (alarmsForDay.length === 0) {
                selectedDayAlarmsList.innerHTML = '<p class="text-gray-500 text-center">No alarms for this date.</p>';
                return;
            }

            renderAlarms(alarmsForDay, selectedDayAlarmsList);
        }

        prevMonthButton.addEventListener('click', () => {
            currentCalendarDate.setMonth(currentCalendarDate.getMonth() - 1);
            renderCalendar(currentCalendarDate.getFullYear(), currentCalendarDate.getMonth());
            // After changing month, re-display alarms for the current selected day (if any)
            if (selectedCalendarDay) {
                displayAlarmsForSelectedDay(parseInt(selectedCalendarDay.dataset.day), currentCalendarDate.getMonth(), currentCalendarDate.getFullYear());
            } else {
                selectedDayAlarmsList.innerHTML = '<p class="text-gray-500 text-center">Please select a date on the calendar.</p>';
                selectedDateDisplay.textContent = 'Please select a date on the calendar.';
            }
        });

        nextMonthButton.addEventListener('click', () => {
            currentCalendarDate.setMonth(currentCalendarDate.getMonth() + 1);
            renderCalendar(currentCalendarDate.getFullYear(), currentCalendarDate.getMonth());
            // After changing month, re-display alarms for the current selected day (if any)
            if (selectedCalendarDay) {
                displayAlarmsForSelectedDay(parseInt(selectedCalendarDay.dataset.day), currentCalendarDate.getMonth(), currentCalendarDate.getFullYear());
            } else {
                selectedDayAlarmsList.innerHTML = '<p class="text-gray-500 text-center">Please select a date on the calendar.</p>';
                selectedDateDisplay.textContent = 'Please select a date on the calendar.';
            }
        });
        
        // --- Chatbot and AI Functions ---
        /**
         * Adds a chat message to the chatbot messages display.
         * @param {string} text - The message text.
         * @param {string} sender - 'user' or 'bot'.
         */
        function addChatMessage(text, sender) {
            const div = document.createElement('div');
            div.className = `chat-message ${sender}-message`;
            div.textContent = text;
            chatbotMessages.appendChild(div);
            chatbotMessages.scrollTop = chatbotMessages.scrollHeight; // Auto-scroll to latest message
        }

        /**
         * Handles the user's chat message submission.
         */
        async function handleChatSend() {
            const userInput = chatbotInput.value.trim();
            if (!userInput) return;

            addChatMessage(userInput, 'user');
            chatbotInput.value = ''; // Clear input

            addChatMessage('Thinking...', 'bot'); // Show thinking message

            await processChatMessage(userInput);
        }

        /**
         * Processes the user's chat message using the backend's AI endpoint.
         * @param {string} message - The user's message.
         */
        async function processChatMessage(message) {
            const lastBotMessage = chatbotMessages.querySelector('.bot-message:last-child');
            try {
                const response = await makeAuthenticatedRequest('/chatbot', {
                    method: 'POST',
                    body: JSON.stringify({ message })
                });
                const resultJson = await response.json();

                if (response.ok && resultJson.date) {
                    lastBotMessage.textContent = `Sure! Looking up tasks for ${resultJson.date}.`;
                    const [year, month, day] = resultJson.date.split('-').map(Number);

                    if (!year || !month || !day || isNaN(new Date(year, month - 1, day))) {
                        throw new Error("Invalid date from API");
                    }

                    // Update calendar and display alarms for the date
                    currentCalendarDate = new Date(year, month - 1, day);
                    renderCalendar(year, month - 1);
                    
                    // Select the day in the calendar grid
                    const dayElement = calendarGrid.querySelector(`.calendar-day[data-day="${day}"]`);
                    if(dayElement) {
                        // Remove selected-day class from previously selected day
                        if(selectedCalendarDay) {
                            selectedCalendarDay.classList.remove('selected-day');
                        }
                        dayElement.classList.add('selected-day');
                        selectedCalendarDay = dayElement;
                        displayAlarmsForSelectedDay(day, month - 1, year);
                    } else {
                        displayAlarmsForSelectedDay(day, month - 1, year);
                    }

                    setTimeout(() => chatbotModal.classList.add('hidden'), 1500);

                } else {
                    lastBotMessage.textContent = resultJson.error || "Sorry, I couldn't understand that.";
                }
            } catch (error) {
                console.error("Chatbot processing error:", error);
                lastBotMessage.textContent = "I had trouble with that request. Please try rephrasing or check server connection.";
            } finally {
                // No button to re-enable for chatbot input, but leaving pattern for consistency if needed.
            }
        }

        generateNameIdeaBtn.addEventListener('click', async () => {
            const prompt = "Suggest a creative and concise alarm/task name idea.";
            try {
                const response = await makeAuthenticatedRequest('/chatbot', {
                    method: 'POST',
                    body: JSON.stringify({ message: prompt })
                });
                const data = await response.json();
                if (response.ok && data.text) { // Assuming backend returns { text: "idea" }
                    alarmNameInput.value = data.text.trim();
                } else {
                    showAlert('AI Idea Error', data.message || 'Could not generate an idea.');
                }
            } catch (error) {
                console.error('AI Idea Error:', error);
                showAlert('Network Error', 'Could not connect to the AI service.');
            }
        });

        enhanceDescriptionBtn.addEventListener('click', async () => {
            if (!alarmDescriptionInput.value) return;
            const prompt = `Enhance this task description: "${alarmDescriptionInput.value}"`;
            try {
                const response = await makeAuthenticatedRequest('/chatbot', {
                    method: 'POST',
                    body: JSON.stringify({ message: prompt })
                });
                const data = await response.json();
                if (response.ok && data.text) { // Assuming backend returns { text: "enhanced_description" }
                    alarmDescriptionInput.value = data.text.trim();
                } else {
                    showAlert('AI Enhance Error', data.message || 'Could not enhance description.');
                }
            } catch (error) {
                console.error('AI Enhance Error:', error);
                showAlert('Network Error', 'Could not connect to the AI service.');
            }
        });

        openChatbotButton.addEventListener('click', () => chatbotModal.classList.remove('hidden'));
        chatbotCloseBtn.addEventListener('click', () => chatbotModal.classList.add('hidden'));
        chatbotSendBtn.addEventListener('click', handleChatSend);
        chatbotInput.addEventListener('keydown', (e) => e.key === 'Enter' && handleChatSend());
        
        // --- Settings and Init ---

        /**
         * Populates the speaker voice select dropdown based on the selected service.
         */
        function populateVoices() {
            const currentService = speakerServiceSelect.value;
            speakerVoiceSelect.innerHTML = ''; // Clear existing options
            prioritizeNaturalVoicesToggle.parentElement.classList.add('hidden'); // Hide by default

            if (currentService === 'browser') {
                prioritizeNaturalVoicesToggle.parentElement.classList.remove('hidden');
                const voices = speechSynthesis.getVoices();
                if (voices.length === 0) {
                    const opt = document.createElement('option');
                    opt.textContent = "No browser voices found.";
                    speakerVoiceSelect.appendChild(opt);
                    return;
                }

                const prioritizeNatural = prioritizeNaturalVoicesToggle.checked;
                const filteredVoices = voices.filter(voice => {
                    const isEnglish = voice.lang.startsWith('en');
                    const isNatural = voice.name.includes('Google') || voice.name.includes('Microsoft') || voice.name.includes('Neural');
                    return isEnglish && (!prioritizeNatural || isNatural);
                }).sort((a,b) => {
                    if (a.default) return -1;
                    if (b.default) return 1;
                    return a.name.localeCompare(b.name);
                });

                filteredVoices.forEach(voice => {
                    const opt = document.createElement('option');
                    opt.value = voice.voiceURI;
                    opt.textContent = `${voice.name} (${voice.lang})${voice.default ? ' - Default' : ''}`;
                    speakerVoiceSelect.appendChild(opt);
                });
                selectedBrowserVoice = voices.find(v => v.voiceURI === (localStorage.getItem('speakerVoiceURI_browser') || speakerVoiceSelect.value));

            } else if (currentService === 'openai') {
                // OpenAI voices are fixed and few, usually don't need a dynamic list from frontend
                const openaiVoices = [
                    { name: "Alloy", id: "alloy" },
                    { name: "Echo", id: "echo" },
                    { name: "Fable", id: "fable" },
                    { name: "Onyx", id: "onyx" },
                    { name: "Nova", id: "nova" },
                    { name: "Shimmer", id: "shimmer" }
                ];
                openaiVoices.forEach(voice => {
                    const opt = document.createElement('option');
                    opt.value = voice.id;
                    opt.textContent = voice.name;
                    speakerVoiceSelect.appendChild(opt);
                });
                speakerVoiceSelect.value = localStorage.getItem('speakerVoiceURI_openai') || 'alloy';

            } else if (currentService === 'elevenlabs') {
                // For ElevenLabs, it's best to fetch available voices from their API via your backend
                // For this example, we'll use a hardcoded default voice ID.
                // In a real app, you'd add a backend endpoint to list ElevenLabs voices.
                const elevenlabsVoices = [
                    { name: "Rachel (Default)", id: "21m00TzPtLmVvB9WbCUs" },
                    { name: "Drew", id: "29vD33N1CtxCmq3hpZad" },
                    { name: "Clyde", id: "25oPftHqB3v0p0o0O0jJ" } // Example additional voice
                ];
                elevenlabsVoices.forEach(voice => {
                    const opt = document.createElement('option');
                    opt.value = voice.id;
                    opt.textContent = voice.name;
                    speakerVoiceSelect.appendChild(opt);
                });
                speakerVoiceSelect.value = localStorage.getItem('speakerVoiceURI_elevenlabs') || '21m00TzPtLmVvB9WbCUs';
            }
        }

        openSettingsButton.addEventListener('click', () => { settingsModal.classList.remove('hidden'); });
        cancelSettingsBtn.addEventListener('click', () => { settingsModal.classList.add('hidden'); });
        saveSettingsBtn.addEventListener('click', () => {
            localStorage.setItem('alarmSoundUrl', alarmSoundSelect.value);
            alarmSound.src = alarmSoundSelect.value;
            
            selectedSpeechService = speakerServiceSelect.value;
            localStorage.setItem('speakerService', selectedSpeechService);

            if (selectedSpeechService === 'browser') {
                localStorage.setItem('speakerVoiceURI_browser', speakerVoiceSelect.value);
                selectedBrowserVoice = speechSynthesis.getVoices().find(v => v.voiceURI === speakerVoiceSelect.value);
                localStorage.setItem('prioritizeNaturalVoices', prioritizeNaturalVoicesToggle.checked);
            } else if (selectedSpeechService === 'openai') {
                localStorage.setItem('speakerVoiceURI_openai', speakerVoiceSelect.value);
            } else if (selectedSpeechService === 'elevenlabs') {
                localStorage.setItem('speakerVoiceURI_elevenlabs', speakerVoiceSelect.value);
            }
            
            settingsModal.classList.add('hidden');
            showAlert('Settings Saved', 'Preferences updated.');
        });

        requestNotificationPermissionButton.addEventListener('click', () => Notification.requestPermission());

        darkModeToggle.addEventListener('change', () => {
            document.body.classList.toggle('dark-theme', darkModeToggle.checked);
            localStorage.setItem('theme', darkModeToggle.checked ? 'dark' : 'light');
        });

        prioritizeNaturalVoicesToggle.addEventListener('change', populateVoices);
        speakerServiceSelect.addEventListener('change', populateVoices);


        // --- Initialization ---
        document.addEventListener('DOMContentLoaded', () => {
            // Apply dark mode if saved
            if (localStorage.getItem('theme') === 'dark') {
                document.body.classList.add('dark-theme');
                darkModeToggle.checked = true;
            }

            // Set up alarm sound select
            const savedSoundUrl = localStorage.getItem('alarmSoundUrl') || ALARM_SOUND_OPTIONS[0].url;
            alarmSound.src = savedSoundUrl;
            ALARM_SOUND_OPTIONS.forEach(s => {
                const o = document.createElement('option');
                o.value = s.url;
                o.textContent = s.name;
                alarmSoundSelect.appendChild(o);
            });
            alarmSoundSelect.value = savedSoundUrl;

            // Load speaker service and voices
            selectedSpeechService = localStorage.getItem('speakerService') || 'browser';
            speakerServiceSelect.value = selectedSpeechService;
            if ('speechSynthesis' in window) {
                speechSynthesis.onvoiceschanged = populateVoices; // Event fires when voices are loaded
            }
            populateVoices(); // Initial call to populate voices based on selected service

            // Set default date and time for new alarm form
            setDefaultAlarmDateTime();

            // Setup auth event listeners
            loginButton.addEventListener('click', loginUser);
            registerButton.addEventListener('click', registerUser);
            logoutButton.addEventListener('click', logoutUser);
            openRegisterModalBtn.addEventListener('click', () => {
                loginModal.classList.add('hidden');
                registerModal.classList.remove('hidden');
            });
            backToLoginBtn.addEventListener('click', () => {
                registerModal.classList.add('hidden');
                loginModal.classList.remove('hidden');
            });
            forgotPasswordBtn.addEventListener('click', async () => {
                const email = await showPromptModal('Forgot Password', 'Please enter your email address to receive a password reset link.', 'email', 'your_email@example.com');
                if (email) {
                    try {
                        const response = await fetch(`${API_BASE_URL}/auth/forgot-password`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ email })
                        });
                        const data = await response.json();
                        if (response.ok) {
                            showAlert('Password Reset', data.message || 'If an account with that email exists, a password reset link has been sent.');
                        } else {
                            showAlert('Password Reset Error', data.message || 'Failed to send password reset link.');
                        }
                    } catch (error) {
                        console.error('Forgot password error:', error);
                        showAlert('Network Error', 'Could not connect to the server for password reset.');
                    }
                }
            });


            // Start time updates and initial auth check
            updateCurrentTimeDisplay();
            setInterval(updateCurrentTimeDisplay, 1000); // Update current time every second
            setInterval(checkAlarms, 1000); // Check alarms every second

            checkAuthAndRender(); // Check auth status on load
        });
    </script>
</body>
</html>
