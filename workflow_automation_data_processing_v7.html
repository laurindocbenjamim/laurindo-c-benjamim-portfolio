<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Workflow Automation</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <script src="https://html2canvas.hertzen.com/dist/html2canvas.min.js"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f3f4f6; /* Light gray background */
            overflow: hidden; /* Prevent body scroll */
        }
        .workflow-area {
            position: relative;
            background-color: #e0e0e0; /* Slightly darker gray background */
            border: 2px dashed #d1d5db; /* Dashed border for drop zone */
            min-height: calc(100vh - 4rem); /* Full height minus header/footer space */
            overflow: hidden; /* Allow scrolling within the workflow area if content exceeds */

            /* Grid background */
            background-image:
                linear-gradient(to right, #d1d5db 1px, transparent 1px), /* Darker grid lines */
                linear-gradient(to bottom, #d1d5db 1px, transparent 1px); /* Darker grid lines */
            background-size: 20px 20px; /* Adjust grid cell size */
            cursor: default; /* Default cursor for workflow area */
        }
        .draggable-block {
            position: absolute;
            cursor: grab;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            transition: transform 0.1s ease-out;
            z-index: 10; /* Ensure blocks are above lines */
        }
        .draggable-block:active {
            cursor: grabbing;
        }
        .draggable-block.selected-for-connection {
            border: 2px solid #3b82f6; /* Blue border when selected for connection */
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.5);
        }
        .draggable-block .connector {
            position: absolute;
            width: 12px; /* Slightly larger for easier clicking */
            height: 12px; /* Slightly larger for easier clicking */
            border-radius: 50%;
            background-color: #6b7280; /* Gray connector */
            border: 1px solid #4b5563;
            cursor: crosshair; /* Indicate connection drawing */
            z-index: 20; /* Above block content */
            transition: background-color 0.2s, transform 0.2s;
        }
        .draggable-block .connector:hover {
            background-color: #3b82f6; /* Highlight on hover */
            transform: scale(1.2) translateY(-50%) !important; /* Scale up on hover */
        }
        .draggable-block .connector.left {
            left: -6px; /* Half of width/height to center */
            top: 50%;
            transform: translateY(-50%);
        }
        .draggable-block .connector.right {
            right: -6px;
            top: 50%;
            transform: translateY(-50%);
        }

        .context-menu {
            position: absolute;
            background-color: white;
            border-radius: 0.5rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            z-index: 100;
            padding: 0.5rem 0;
        }
        .context-menu-item {
            padding: 0.5rem 1rem;
            cursor: pointer;
            font-size: 0.875rem;
            color: #374151;
        }
        .context-menu-item:hover {
            background-color: #f3f4f6;
        }
        /* Canvas for connections */
        #connection-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none; /* Allow clicks to pass through canvas */
            z-index: 5; /* Ensure lines are below blocks */
        }

        /* Message Box styles (for all modals) */
        .message-box-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease, visibility 0.3s ease;
        }
        .message-box-overlay.active {
            opacity: 1;
            visibility: visible;
        }
        .message-box {
            background-color: white;
            padding: 1.5rem;
            border-radius: 0.75rem;
            box-shadow: 0 10px 15px rgba(0, 0, 0, 0.1);
            max-width: 500px;
            width: 90%;
            text-align: center;
            transform: translateY(-20px);
            transition: transform 0.3s ease;
        }
        .message-box-overlay.active .message-box {
            transform: translateY(0);
        }

        .message-box h3 {
            font-size: 1.25rem;
            font-weight: 600;
            margin-bottom: 1rem;
            color: #1f2937;
        }
        .message-box p {
            font-size: 1rem;
            color: #4b5563;
            margin-bottom: 1.5rem;
            text-align: left; /* Align text content left */
            white-space: pre-wrap; /* Preserve whitespace and line breaks */
            word-break: break-word; /* Break long words */
            max-height: 300px; /* Limit height for long messages */
            overflow-y: auto; /* Add scroll for overflow */
        }
        .message-box button {
            background-color: #3b82f6;
            color: white;
            padding: 0.75rem 1.5rem;
            border-radius: 0.5rem;
            font-weight: 500;
            cursor: pointer;
            transition: background-color 0.2s ease-in-out;
        }
        .message-box button:hover {
            background-color: #2563eb;
        }

        /* Progress Bar styles */
        .progress-bar-container {
            width: 100%;
            background-color: #4b5563; /* Dark background for the bar container */
            border-radius: 0.5rem;
            overflow: hidden;
            height: 1rem; /* Height of the progress bar */
            margin-top: 1rem;
        }
        .progress-bar-fill {
            height: 100%;
            width: 0%;
            background-color: #34d399; /* Green fill color */
            border-radius: 0.5rem;
            transition: width 0.1s ease-in-out;
        }

        /* Media Player Icon Styles */
        .media-icon {
            cursor: pointer;
            margin-left: 0.5rem;
            flex-shrink: 0; /* Prevent icon from shrinking */
        }

        /* Settings Modal Specifics (override general message-box styles for size) */
        #settings-modal {
            max-width: 280px; /* Smaller width */
            padding: 0.75rem; /* Reduced padding */
        }
        #settings-modal h3 {
            font-size: 0.95rem; /* Smaller font size */
            margin-bottom: 0.4rem; /* Reduced margin */
        }
        #settings-modal button {
            padding: 0.4rem 0.8rem; /* Reduced padding */
            font-size: 0.75rem; /* Smaller font size */
        }
        #preprocessing-options {
            margin-top: 0.6rem;
            padding-left: 0.6rem;
            border-left: 1px solid #d1d5db;
        }
        #preprocessing-options.hidden {
            display: none;
        }
        #settings-modal-close {
            margin-top: 1rem;
        }
        #settings-modal .form-radio + span,
        #settings-modal .form-checkbox + span {
            font-size: 0.8rem; /* Smaller font for labels in settings */
        }


        /* LLM Modal */
        #llm-modal {
            max-width: 600px;
            width: 90%;
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }
        #llm-modal-input-area {
            width: 100%;
            height: 100px;
            padding: 0.75rem;
            border: 1px solid #d1d5db;
            border-radius: 0.5rem;
            resize: vertical;
            font-size: 0.9rem;
        }
        #llm-modal-response-area {
            background-color: #f3f4f6;
            padding: 0.75rem;
            border-radius: 0.5rem;
            min-height: 100px;
            max-height: 300px;
            overflow-y: auto;
            white-space: pre-wrap;
            font-family: monospace;
            font-size: 0.85rem;
            color: #374151;
            border: 1px solid #e5e7eb;
        }
        #llm-modal-loading-spinner {
            border: 4px solid rgba(0, 0, 0, 0.1);
            border-top: 4px solid #3b82f6;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            animation: spin 1s linear infinite;
            margin: 0 auto;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* New: Error Icon on blocks */
        .error-icon {
            position: absolute;
            top: 4px; /* Adjust as needed */
            right: 4px; /* Adjust as needed */
            width: 18px;
            height: 18px;
            color: #ef4444; /* Red color for error */
            cursor: pointer;
            z-index: 25; /* Ensure it's above other block elements */
        }
        .error-icon:hover {
            transform: scale(1.1);
        }

        /* Reduced size for left menu palette buttons */
        .aside-palette-item {
            padding: 0.6rem; /* Reduced padding */
            font-size: 0.875rem; /* Equivalent to text-sm */
        }
        .aside-palette-item svg {
            height: 1.25rem; /* Smaller icon size */
            width: 1.25rem; /* Smaller icon size */
            margin-bottom: 0.25rem; /* Adjusted margin */
        }
    </style>
</head>
<body class="flex flex-col h-screen">
    <header class="bg-gradient-to-r from-blue-500 to-indigo-600 text-white p-4 shadow-lg flex justify-between items-center">
        <h1 class="text-2xl font-bold">Workflow Automation Tool</h1>
        <div class="flex space-x-4 items-center">
            <button id="display-connections-btn" class="p-2 bg-blue-700 hover:bg-blue-800 rounded-lg transition duration-200 ease-in-out shadow-md flex items-center justify-center">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 text-white" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M4 6h16M4 12h16M4 18h16" />
                </svg>
            </button>
            <button id="save-image-btn" class="p-2 bg-teal-600 hover:bg-teal-700 rounded-lg transition duration-200 ease-in-out shadow-md flex items-center justify-center">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 text-white" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4" />
                </svg>
            </button>
            <button id="start-automation-btn" class="px-4 py-2 bg-purple-600 hover:bg-purple-700 rounded-lg font-medium transition duration-200 ease-in-out shadow-md">
                Start Automation
            </button>
        </div>
    </header>

    <div class="flex flex-1 overflow-hidden">
        <aside class="w-64 bg-gray-800 text-white p-4 flex flex-col space-y-4 shadow-lg overflow-y-auto">
            <h2 class="text-xl font-semibold mb-4 text-gray-200">Blocks</h2>
            <div id="text-box-palette" draggable="true" class="aside-palette-item p-3 bg-blue-500 hover:bg-blue-600 rounded-lg cursor-grab text-center font-medium transition duration-200 ease-in-out shadow-md flex flex-col items-center">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 mb-1" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" />
                </svg>
                Text Box
            </div>
            <div id="file-upload-palette" draggable="true" class="aside-palette-item p-3 bg-green-500 hover:bg-green-600 rounded-lg cursor-grab text-center font-medium transition duration-200 ease-in-out shadow-md flex flex-col items-center">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 mb-1" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M3 7v10a2 2 0 002 2h14a2 2 0 002-2V9a2 2 0 00-2-2h-6l-2-2H5a2 2 0 00-2 2z" />
                </svg>
                File Upload
            </div>
            <div id="json-list-palette" draggable="true" class="aside-palette-item p-3 bg-yellow-500 hover:bg-yellow-600 rounded-lg cursor-grab text-center font-medium transition duration-200 ease-in-out shadow-md flex flex-col items-center">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 mb-1" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M10 20l4-16m4 4l4 4-4 4M6 16l-4-4 4-4" />
                </svg>
                JSON/List
            </div>

            <h2 class="text-xl font-semibold mb-4 text-gray-200 mt-6">Connections</h2>
            <p class="text-xs text-gray-400 mb-2">Click a connector point, then drag to another!</p>
            <div class="p-3 bg-gray-700 rounded-lg text-center font-medium text-gray-300">
                Draw connections directly on blocks.
            </div>

            <div class="mt-auto pt-4 border-t border-gray-700 text-sm text-gray-400">
                <p>Drag and drop blocks to the right area.</p>
                <p>Right-click a block to connect or delete.</p>
                <p>Double-click a block title to edit.</p>
            </div>

            <div id="progress-bar-wrapper" class="hidden mt-4">
                <p class="text-xs text-gray-400 mb-1">Automation Progress:</p>
                <div class="progress-bar-container">
                    <div id="progress-bar-fill" class="progress-bar-fill"></div>
                </div>
            </div>

            <div class="mt-6 pt-4 border-t border-gray-700">
                <h2 class="text-xl font-semibold mb-2 text-gray-200">Default Connection Type</h2>
                <div class="flex flex-col space-y-2 text-sm text-gray-300">
                    <label class="flex items-center space-x-2">
                        <input type="radio" name="connectionType" value="solid" checked class="form-radio text-blue-600">
                        <span>Solid Line</span>
                    </label>
                    <label class="flex items-center space-x-2">
                        <input type="radio" name="connectionType" value="dashed" class="form-radio text-blue-600">
                        <span>Dashed Line</span>
                    </label>
                    <label class="flex items-center space-x-2">
                        <input type="radio" name="connectionType" value="arrow" class="form-radio text-blue-600">
                        <span>Arrow Line</span>
                    </label>
                </div>
            </div>
        </aside>

        <main id="workflow-area" class="flex-1 p-6 workflow-area overflow-auto">
            <div class="w-full mb-8 flex justify-center">
                <input type="text" id="workflow-title" placeholder="Enter Workflow Title" 
                       class="text-center text-2xl font-bold text-gray-800 bg-transparent border-b-2 border-gray-300 
                              focus:outline-none focus:border-blue-500 transition-colors duration-200 px-4 py-2 rounded-md"
                       value="My Awesome Workflow">
            </div>

            <p class="text-center text-gray-400 text-lg mt-20">Drag blocks here to start your workflow...</p>

            <canvas id="connection-canvas"></canvas>
        </main>
    </div>

    <div id="context-menu" class="context-menu hidden">
        <div class="context-menu-item" data-action="remove-connection">Remove Connection</div>
        <div class="context-menu-item" data-action="delete">Delete</div>
    </div>

    <div id="message-box-container" class="message-box-overlay">
        <div class="message-box">
            <h3 id="message-box-title"></h3>
            <p id="message-box-content"></p>
            <button id="message-box-ok">OK</button>
        </div>
    </div>

    <div id="video-modal-container" class="message-box-overlay">
        <div class="message-box">
            <h3 id="video-modal-title">Video Preview</h3>
            <video id="video-player" controls class="w-full h-auto rounded-md mb-4"></video>
            <button id="video-modal-close">Close</button>
        </div>
    </div>

    <div id="settings-modal-container" class="message-box-overlay">
        <div id="settings-modal" class="message-box">
            <h3 class="text-xl font-bold mb-4">Settings</h3>
            <div class="flex flex-col space-y-3">
                <div class="flex flex-col space-y-2 text-sm text-gray-700">
                    <p class="font-semibold mb-1">Model Creation:</p>
                    <label class="flex items-center space-x-2">
                        <input type="radio" name="modelCreation" value="noModel" id="no-model-option" class="form-radio text-blue-600">
                        <span>No Model</span>
                    </label>
                    <label class="flex items-center space-x-2">
                        <input type="radio" name="modelCreation" value="createModel" id="create-model-option" class="form-radio text-blue-600">
                        <span>Create Model</span>
                    </label>
                </div>
                <button id="preprocessing-option" class="px-4 py-2 bg-green-500 hover:bg-green-600 text-white rounded-lg font-medium">Preprocessing</button>
            </div>
            <div id="preprocessing-options" class="hidden mt-4 text-left">
                <p class="font-semibold mb-2">Preprocessing Options:</p>
                <label class="flex items-center space-x-2 mb-1">
                    <input type="checkbox" id="clean-missing-value" class="form-checkbox text-blue-600 rounded">
                    <span>Clean missing value</span>
                </label>
                <label class="flex items-center space-x-2 mb-1">
                    <input type="checkbox" id="remove-missing" class="form-checkbox text-blue-600 rounded">
                    <span>Remove missing</span>
                </label>
                <label class="flex items-center space-x-2 mb-1">
                    <input type="checkbox" id="handle-outlier" class="form-checkbox text-blue-600 rounded">
                    <span>Handle outlier</span>
                </label>
                <label class="flex items-center space-x-2 mb-1">
                    <input type="checkbox" id="handle-asymmetries" class="form-checkbox text-blue-600 rounded">
                    <span>Handle asymmetries</span>
                </label>
                <label class="flex items-center space-x-2 mb-1">
                    <input type="checkbox" id="use-ai" class="form-checkbox text-blue-600 rounded">
                    <span>Use AI</span>
                </label>
            </div>
            <button id="settings-modal-close" class="mt-6 px-4 py-2 bg-gray-300 hover:bg-gray-400 text-gray-800 rounded-lg font-medium">Close</button>
        </div>
    </div>

    <div id="llm-modal-container" class="message-box-overlay">
        <div id="llm-modal" class="message-box">
            <h3 id="llm-modal-title" class="text-xl font-bold">AI Assistant</h3>
            <textarea id="llm-modal-input-area" placeholder="Enter your instructions or content here..."></textarea>
            <div class="flex justify-center items-center h-8">
                <div id="llm-modal-loading-spinner" class="hidden"></div>
            </div>
            <div id="llm-modal-response-area" class="border p-2 min-h-[100px] max-h-[300px] overflow-y-auto">
                AI Response will appear here.
            </div>
            <div class="flex justify-end space-x-3">
                <button id="llm-modal-apply-btn" class="px-4 py-2 bg-indigo-500 hover:bg-indigo-600 text-white rounded-lg font-medium">Apply to Block</button>
                <button id="llm-modal-generate-btn" class="px-4 py-2 bg-purple-500 hover:bg-purple-600 text-white rounded-lg font-medium">Generate/Process</button>
                <button id="llm-modal-close-btn" class="px-4 py-2 bg-gray-300 hover:bg-gray-400 text-gray-800 rounded-lg font-medium">Close</button>
            </div>
        </div>
    </div>

    <script>
        const workflowArea = document.getElementById('workflow-area');
        const workflowTitleInput = document.getElementById('workflow-title'); // New: Workflow Title Input
        const textBoxPalette = document.getElementById('text-box-palette');
        const fileUploadPalette = document.getElementById('file-upload-palette');
        const jsonListPalette = document.getElementById('json-list-palette');
        const connectionCanvas = document.getElementById('connection-canvas');
        const ctx = connectionCanvas.getContext('2d');
        const contextMenu = document.getElementById('context-menu');
        const startAutomationBtn = document.getElementById('start-automation-btn');
        const displayConnectionsBtn = document.getElementById('display-connections-btn');
        const saveImageBtn = document.getElementById('save-image-btn');
        const messageBoxContainer = document.getElementById('message-box-container');
        const messageBoxTitle = document.getElementById('message-box-title');
        const messageBoxContent = document.getElementById('message-box-content');
        const messageBoxOkBtn = document.getElementById('message-box-ok');
        const progressBarWrapper = document.getElementById('progress-bar-wrapper');
        const progressBarFill = document.getElementById('progress-bar-fill');

        const videoModalContainer = document.getElementById('video-modal-container');
        const videoPlayer = document.getElementById('video-player');
        const videoModalCloseBtn = document.getElementById('video-modal-close');

        const settingsModalContainer = document.getElementById('settings-modal-container');
        const settingsModalCloseBtn = document.getElementById('settings-modal-close');
        const createModelOptionRadio = document.getElementById('create-model-option'); // Renamed for clarity
        const noModelOptionRadio = document.getElementById('no-model-option'); // New radio button
        const preprocessingOption = document.getElementById('preprocessing-option');
        const preprocessingOptionsDiv = document.getElementById('preprocessing-options');

        const llmModalContainer = document.getElementById('llm-modal-container');
        const llmModalTitle = document.getElementById('llm-modal-title');
        const llmModalInputArea = document.getElementById('llm-modal-input-area');
        const llmModalResponseArea = document.getElementById('llm-modal-response-area');
        const llmModalLoadingSpinner = document.getElementById('llm-modal-loading-spinner');
        const llmModalApplyBtn = document.getElementById('llm-modal-apply-btn');
        const llmModalGenerateBtn = document.getElementById('llm-modal-generate-btn');
        const llmModalCloseBtn = document.getElementById('llm-modal-close-btn');

        // New: Connection type radio buttons
        const connectionTypeRadios = document.querySelectorAll('input[name="connectionType"]');
        let defaultConnectionType = 'solid'; // Default connection type

        connectionTypeRadios.forEach(radio => {
            radio.addEventListener('change', (e) => {
                defaultConnectionType = e.target.value;
            });
        });


        let blockCounter = 0;
        let blocks = {}; // Stores block elements and their data
        let connections = []; // Stores connection data { fromBlock: id, fromSide: 'left'|'right', toBlock: id, toSide: 'left'|'right', type: 'solid'|'dashed'|'arrow' }

        let currentContextMenuBlockId = null; // ID of the block that triggered the context menu
        let activeSettingsBlockId = null; // ID of the block whose settings are currently open
        let activeLlmBlockId = null; // To keep track of which block opened the LLM modal

        // Connection drawing state for canvas
        let isDrawingConnection = false;
        let startConnector = null; // { blockId: 'block-id', side: 'left'|'right', element: HTMLElement }
        let currentMouseX = 0;
        let currentMouseY = 0;

        // Store workflow title
        let workflowTitle = workflowTitleInput.value;
        workflowTitleInput.addEventListener('input', (e) => {
            workflowTitle = e.target.value;
        });


        // --- Canvas Setup ---
        function resizeCanvas() {
            connectionCanvas.width = workflowArea.offsetWidth;
            connectionCanvas.height = workflowArea.offsetHeight;
            drawAllConnections(); // Redraw connections after resize
        }

        // Initialize canvas size on load
        window.addEventListener('load', resizeCanvas);
        // Update canvas size and redraw on window resize
        window.addEventListener('resize', resizeCanvas);

        function clearCanvas() {
            ctx.clearRect(0, 0, connectionCanvas.width, connectionCanvas.height);
        }

        function drawConnection(connection) {
            const fromBlockElement = blocks[connection.fromBlock]?.element;
            const toBlockElement = blocks[connection.toBlock]?.element;

            if (!fromBlockElement || !toBlockElement) {
                console.error("One or both block elements not found for connection drawing:", connection);
                return;
            }

            // Find the actual connector elements
            const fromConnectorElement = fromBlockElement.querySelector(`.connector.${connection.fromSide}`);
            const toConnectorElement = toBlockElement.querySelector(`.connector.${connection.toSide}`);

            if (!fromConnectorElement || !toConnectorElement) {
                console.error("Connector elements not found for connection:", connection);
                return;
            }

            const fromPoint = getConnectorAbsolutePosition(fromConnectorElement);
            const toPoint = getConnectorAbsolutePosition(toConnectorElement);

            ctx.beginPath();
            ctx.moveTo(fromPoint.x, fromPoint.y);
            
            // Calculate control points for a cubic Bézier curve
            // This creates the "flexible" S-shape
            const dx = Math.abs(fromPoint.x - toPoint.x);
            const cp1x = fromPoint.x + dx * 0.5;
            const cp1y = fromPoint.y;
            const cp2x = toPoint.x - dx * 0.5;
            const cp2y = toPoint.y;

            ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, toPoint.x, toPoint.y);

            ctx.strokeStyle = '#4b5563'; // Dark gray line
            ctx.lineWidth = 2;
            ctx.lineCap = 'round'; // Added for smoother lines
            ctx.lineJoin = 'round'; // Added for smoother lines

            if (connection.type === 'dashed') {
                ctx.setLineDash([5, 5]);
            } else if (connection.type === 'arrow') {
                ctx.setLineDash([]); // Solid for arrow base
                // Draw arrow head at the 'to' end
                drawArrowhead(ctx, fromPoint.x, fromPoint.y, toPoint.x, toPoint.y, '#4b5563');
            }
            else {
                ctx.setLineDash([]); // Solid line
            }
            ctx.stroke();
        }

        function drawArrowhead(context, fromX, fromY, toX, toY, color) {
            const headlen = 10; // length of head in pixels
            const dx = toX - fromX;
            const dy = toY - fromY;
            const angle = Math.atan2(dy, dx);

            context.save();
            context.beginPath();
            context.strokeStyle = color;
            context.fillStyle = color;
            context.moveTo(toX, toY);
            context.lineTo(toX - headlen * Math.cos(angle - Math.PI / 6), toY - headlen * Math.sin(angle - Math.PI / 6));
            context.lineTo(toX - headlen * Math.cos(angle + Math.PI / 6), toY - headlen * Math.sin(angle + Math.PI / 6));
            context.closePath();
            context.fill();
            context.restore();
        }

        function drawAllConnections() {
            clearCanvas();
            connections.forEach(drawConnection);
        }

        // --- Utility for showing custom message box / modals ---
        function showModal(modalElement) {
            modalElement.classList.add('active');
        }

        function hideModal(modalElement) {
            modalElement.classList.remove('active');
        }

        function showMessageBox(title, message) {
            messageBoxTitle.textContent = title;
            messageBoxContent.textContent = message;
            showModal(messageBoxContainer);
        }

        messageBoxOkBtn.addEventListener('click', () => {
            hideModal(messageBoxContainer);
        });

        // --- Video Modal Logic ---
        function showVideoModal(fileUrl) {
            videoPlayer.src = fileUrl;
            showModal(videoModalContainer);
            videoPlayer.play(); // Auto-play video
        }

        videoModalCloseBtn.addEventListener('click', () => {
            videoPlayer.pause();
            videoPlayer.src = ''; // Clear source to release memory
            hideModal(videoModalContainer);
        });

        // --- Settings Modal Logic ---
        settingsModalCloseBtn.addEventListener('click', () => {
            hideModal(settingsModalContainer);
            preprocessingOptionsDiv.classList.add('hidden'); // Hide preprocessing options when closing
            activeSettingsBlockId = null; // Clear active block ID
        });

        preprocessingOption.addEventListener('click', () => {
            preprocessingOptionsDiv.classList.toggle('hidden');
        });

        // Event listener for model creation radio buttons
        document.querySelectorAll('input[name="modelCreation"]').forEach(radio => {
            radio.addEventListener('change', (e) => {
                if (activeSettingsBlockId && blocks[activeSettingsBlockId]) {
                    blocks[activeSettingsBlockId].settings.createModel = (e.target.value === 'createModel');
                }
            });
        });

        // Event listener for preprocessing checkboxes
        preprocessingOptionsDiv.querySelectorAll('input[type="checkbox"]').forEach(checkbox => {
            checkbox.addEventListener('change', (e) => {
                if (activeSettingsBlockId && blocks[activeSettingsBlockId]) {
                    // Convert checkbox ID (e.g., 'clean-missing-value') to camelCase property name (e.g., 'cleanMissingValue')
                    const propertyName = e.target.id.replace(/-([a-z])/g, (g) => g[1].toUpperCase());
                    blocks[activeSettingsBlockId].settings.preprocessing[propertyName] = e.target.checked;
                }
            });
        });


        // --- LLM Modal Logic ---
        llmModalCloseBtn.addEventListener('click', () => {
            hideModal(llmModalContainer);
            llmModalInputArea.value = '';
            llmModalResponseArea.textContent = 'AI Response will appear here.';
            llmModalLoadingSpinner.classList.add('hidden');
            llmModalGenerateBtn.disabled = false;
            llmModalApplyBtn.disabled = true;
            activeLlmBlockId = null;
        });

        llmModalApplyBtn.addEventListener('click', () => {
            if (activeLlmBlockId && blocks[activeLlmBlockId]) {
                const block = blocks[activeLlmBlockId];
                if (block.type === 'text-box') {
                    block.element.querySelector('textarea').value = llmModalResponseArea.textContent;
                    block.content = llmModalResponseArea.textContent;
                } else if (block.type === 'json-list-box') {
                    block.element.querySelector('textarea').value = llmModalResponseArea.textContent;
                    block.content = llmModalResponseArea.textContent;
                }
                llmModalCloseBtn.click(); // Close modal after applying
            }
        });

        llmModalGenerateBtn.addEventListener('click', async () => {
            const prompt = llmModalInputArea.value;
            if (!prompt.trim()) {
                showMessageBox("Input Required", "Please enter your instructions or content for the AI.");
                return;
            }

            llmModalLoadingSpinner.classList.remove('hidden');
            llmModalGenerateBtn.disabled = true;
            llmModalApplyBtn.disabled = true;
            llmModalResponseArea.textContent = 'Generating response...';

            let llmPrompt = "";
            if (blocks[activeLlmBlockId].type === 'text-box') {
                llmPrompt = `Analyze the following text. If it's short, elaborate on it. If it's long, summarize it. If it's a command, execute it (e.g., "translate to French"). Respond only with the processed text:\n\n${prompt}`;
            } else if (blocks[activeLlmBlockId].type === 'json-list-box') {
                llmPrompt = `Process the following data. If it's a description, generate a valid JSON or list based on it. If it's existing JSON/list, validate and pretty-print it, or apply transformations if requested. Respond only with the processed JSON/list:\n\n${prompt}`;
            }

            try {
                const payload = { contents: [{ role: "user", parts: [{ text: llmPrompt }] }] };
                const apiKey = ""; // Canvas will provide this at runtime
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;
                
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                
                const result = await response.json();
                if (result.candidates && result.candidates.length > 0 &&
                    result.candidates[0].content && result.candidates[0].content.parts &&
                    result.candidates[0].content.parts.length > 0) {
                    const text = result.candidates[0].content.parts[0].text;
                    llmModalResponseArea.textContent = text;
                    llmModalApplyBtn.disabled = false;
                } else {
                    llmModalResponseArea.textContent = 'Error: Could not get a valid response from AI.';
                    console.error('Gemini API response structure unexpected:', result);
                }
            } catch (error) {
                llmModalResponseArea.textContent = `Error calling AI: ${error.message}`;
                console.error('Error in Gemini API call:', error);
            } finally {
                llmModalLoadingSpinner.classList.add('hidden');
                llmModalGenerateBtn.disabled = false;
            }
        });

        // --- Drag and Drop from Palette ---
        textBoxPalette.addEventListener('dragstart', (e) => { e.dataTransfer.setData('text/plain', 'text-box'); });
        fileUploadPalette.addEventListener('dragstart', (e) => { e.dataTransfer.setData('text/plain', 'file-upload'); });
        jsonListPalette.addEventListener('dragstart', (e) => { e.dataTransfer.setData('text/plain', 'json-list-box'); });

        workflowArea.addEventListener('dragover', (e) => {
            e.preventDefault(); // Allow drop
            workflowArea.style.borderColor = '#60a5fa'; // Highlight drop zone
            
            // Update temp line if drawing a connection
            if (isDrawingConnection && startConnector) {
                const workflowAreaRect = workflowArea.getBoundingClientRect();
                currentMouseX = e.clientX - workflowAreaRect.left;
                currentMouseY = e.clientY - workflowAreaRect.top;
                
                clearCanvas();
                drawAllConnections(); // Redraw existing connections
                
                ctx.beginPath();
                ctx.moveTo(getConnectorAbsolutePosition(startConnector.element).x, getConnectorAbsolutePosition(startConnector.element).y);
                
                // Draw temporary Bézier curve
                const tempDx = Math.abs(getConnectorAbsolutePosition(startConnector.element).x - currentMouseX);
                const tempCp1x = getConnectorAbsolutePosition(startConnector.element).x + tempDx * 0.5;
                const tempCp1y = getConnectorAbsolutePosition(startConnector.element).y;
                const tempCp2x = currentMouseX - tempDx * 0.5;
                const tempCp2y = currentMouseY;

                ctx.bezierCurveTo(tempCp1x, tempCp1y, tempCp2x, tempCp2y, currentMouseX, currentMouseY);

                ctx.strokeStyle = '#3b82f6';
                ctx.lineWidth = 2;
                ctx.setLineDash([]); // Solid for temp line
                ctx.stroke();
            }
        });

        workflowArea.addEventListener('dragleave', () => {
            workflowArea.style.borderColor = '#d1d5db'; // Reset border
        });

        workflowArea.addEventListener('drop', (e) => {
            e.preventDefault();
            workflowArea.style.borderColor = '#d1d5db'; // Reset border

            const type = e.dataTransfer.getData('text/plain');
            const newBlockId = `block-${blockCounter++}`;
            const blockElement = createBlockElement(type, newBlockId);

            // Calculate position relative to workflow area
            const workflowAreaRect = workflowArea.getBoundingClientRect();
            let x = e.clientX - workflowAreaRect.left - (blockElement.offsetWidth / 2);
            let y = e.clientY - workflowAreaRect.top - (blockElement.offsetHeight / 2);

            // Ensure block stays within bounds (optional, but good for UX)
            x = Math.max(0, Math.min(x, workflowAreaRect.width - blockElement.offsetWidth));
            y = Math.max(0, Math.min(y, workflowAreaRect.offsetHeight - blockElement.offsetHeight));

            blockElement.style.left = `${x}px`;
            blockElement.style.top = `${y}px`;

            workflowArea.appendChild(blockElement);
            
            // Use setTimeout to ensure element is rendered and has correct dimensions
            setTimeout(() => {
                blocks[newBlockId] = {
                    element: blockElement,
                    type: type,
                    x: x,
                    y: y,
                    width: blockElement.offsetWidth,
                    height: blockElement.offsetHeight,
                    title: getDefaultTitle(type), // Default title based on type
                    content: '', // For text boxes, store content; for file uploads, store file name
                    settings: { // Unique settings for each block
                        createModel: false, // Default to no model
                        preprocessing: {
                            cleanMissingValue: false,
                            removeMissing: false,
                            handleOutlier: false,
                            handleAsymmetries: false,
                            useAi: false
                        }
                    },
                    hasError: false, // New: Error state for the block
                    errorMessage: '' // New: Error message for the block
                };
                makeBlockDraggable(blockElement, newBlockId);
                updatePlaceholderVisibility();
            }, 0); // Small delay to allow rendering
        });

        workflowArea.addEventListener('mouseup', (e) => {
            if (isDrawingConnection) {
                // If mouseup happens on workflow area (not a connector), cancel drawing
                const targetConnector = e.target.closest('.connector');
                if (!targetConnector) {
                    isDrawingConnection = false;
                    startConnector = null;
                    drawAllConnections(); // Clear temp line
                }
            }
        });


        function getDefaultTitle(type) {
            switch (type) {
                case 'text-box': return 'Text Block';
                case 'file-upload': return 'File Upload';
                case 'json-list-box': return 'JSON/List Block';
                default: return 'Block';
            }
        }

        // --- Create Block Element ---
        function createBlockElement(type, id) {
            const block = document.createElement('div');
            block.id = id;
            block.classList.add('draggable-block', 'p-4', 'rounded-lg', 'bg-white', 'border', 'border-gray-200', 'flex', 'flex-col', 'items-center', 'justify-center');
            block.style.minWidth = '120px'; // Minimum width for blocks
            block.style.minHeight = '80px'; // Minimum height for blocks

            const titleContainer = document.createElement('div');
            titleContainer.classList.add('flex', 'items-center', 'justify-center', 'mb-2', 'w-full'); // Flex container for title and icons

            const titleElement = document.createElement('p');
            titleElement.classList.add('font-semibold', 'cursor-text', 'flex-grow'); // Add cursor-text for double-click hint
            titleElement.textContent = getDefaultTitle(type);

            // Double-click to edit title
            titleElement.addEventListener('dblclick', (e) => {
                e.stopPropagation(); // Prevent block drag/connection logic
                const input = document.createElement('input');
                input.type = 'text';
                input.value = titleElement.textContent;
                input.classList.add('w-full', 'p-1', 'text-sm', 'rounded-md', 'border', 'border-gray-300', 'focus:outline-none', 'focus:ring-2', 'focus:ring-blue-400');
                
                titleElement.replaceWith(input);
                input.focus();

                const saveTitle = () => {
                    titleElement.textContent = input.value || getDefaultTitle(type);
                    input.replaceWith(titleElement);
                    blocks[id].title = titleElement.textContent; // Update block data
                };

                input.addEventListener('blur', saveTitle);
                input.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') {
                        saveTitle();
                    }
                });
            });

            titleContainer.appendChild(titleElement);

            // Add settings button to block
            const settingsBtnBlock = document.createElement('button');
            settingsBtnBlock.classList.add('p-1', 'ml-2', 'rounded-full', 'hover:bg-gray-200', 'transition', 'duration-150');
            settingsBtnBlock.innerHTML = `
                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 text-gray-600" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z" />
                    <path stroke-linecap="round" stroke-linejoin="round" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" />
                </svg>
            `;
            settingsBtnBlock.addEventListener('click', (e) => {
                e.stopPropagation(); // Prevent block drag/connection logic
                activeSettingsBlockId = id; // Set the ID of the block whose settings are opened
                
                // Populate checkboxes based on the block's current settings
                const blockSettings = blocks[id].settings;
                document.getElementById('clean-missing-value').checked = blockSettings.preprocessing.cleanMissingValue;
                document.getElementById('remove-missing').checked = blockSettings.preprocessing.removeMissing;
                document.getElementById('handle-outlier').checked = blockSettings.preprocessing.handleOutlier;
                document.getElementById('handle-asymmetries').checked = blockSettings.preprocessing.handleAsymmetries;
                document.getElementById('use-ai').checked = blockSettings.preprocessing.useAi;

                // Set model creation radio button
                if (blockSettings.createModel) {
                    createModelOptionRadio.checked = true;
                } else {
                    noModelOptionRadio.checked = true;
                }

                showModal(settingsModalContainer);
            });
            titleContainer.appendChild(settingsBtnBlock);

            // New: Error Icon
            const errorIcon = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            errorIcon.classList.add('error-icon', 'hidden'); // Hidden by default
            errorIcon.setAttribute('fill', 'none');
            errorIcon.setAttribute('viewBox', '0 0 24 24');
            errorIcon.setAttribute('stroke', 'currentColor');
            errorIcon.setAttribute('stroke-width', '2');
            errorIcon.innerHTML = '<path stroke-linecap="round" stroke-linejoin="round" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z" />';
            errorIcon.addEventListener('click', (e) => {
                e.stopPropagation();
                const blockError = blocks[id];
                if (blockError.hasError) {
                    showMessageBox("Block Error", blockError.errorMessage);
                }
            });
            block.appendChild(errorIcon);


            block.appendChild(titleContainer);

            if (type === 'text-box') {
                block.classList.add('bg-blue-100', 'border-blue-300');
                const textarea = document.createElement('textarea');
                textarea.classList.add('w-full', 'h-16', 'p-2', 'text-sm', 'rounded-md', 'border', 'border-blue-200', 'focus:outline-none', 'focus:ring-2', 'focus:ring-blue-400', 'resize-none');
                textarea.placeholder = "Enter text...";
                textarea.addEventListener('input', () => {
                    blocks[id].content = textarea.value; // Update content in block data
                });
                block.appendChild(textarea);

                // Add AI button for Text Box
                const aiButton = document.createElement('button');
                aiButton.classList.add('mt-2', 'px-3', 'py-1', 'bg-blue-600', 'hover:bg-blue-700', 'text-white', 'text-xs', 'rounded-md', 'font-medium', 'shadow-sm');
                aiButton.textContent = '✨ AI Text ✨';
                aiButton.addEventListener('click', (e) => {
                    e.stopPropagation(); // Prevent block drag/connection logic
                    activeLlmBlockId = id;
                    llmModalTitle.textContent = 'AI Text Assistant';
                    llmModalInputArea.value = blocks[id].content;
                    llmModalResponseArea.textContent = 'AI Response will appear here.';
                    llmModalApplyBtn.disabled = true;
                    showModal(llmModalContainer);
                });
                block.appendChild(aiButton);

            } else if (type === 'file-upload') {
                block.classList.add('bg-green-100', 'border-green-300');
                const input = document.createElement('input');
                input.type = 'file';
                input.classList.add('w-full', 'text-sm', 'text-gray-500', 'file:mr-4', 'file:py-2', 'file:px-4', 'file:rounded-full', 'file:border-0', 'file:text-sm', 'file:font-semibold', 'file:bg-green-50', 'file:text-green-700', 'hover:file:bg-green-100', 'cursor-pointer');
                
                // Placeholder for media icon
                const mediaIcon = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                mediaIcon.setAttribute('class', 'h-5 w-5 text-gray-600 media-icon hidden');
                mediaIcon.setAttribute('fill', 'none');
                mediaIcon.setAttribute('viewBox', '0 0 24 24');
                mediaIcon.setAttribute('stroke', 'currentColor');
                mediaIcon.setAttribute('stroke-width', '2');
                const mediaIconPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                mediaIconPath.setAttribute('stroke-linecap', 'round');
                mediaIconPath.setAttribute('stroke-linejoin', 'round');
                mediaIcon.appendChild(mediaIconPath);
                titleContainer.appendChild(mediaIcon);

                let currentMediaObjectUrl = null; // To store object URL for cleanup
                let currentAudioPlayer = null; // To manage audio playback

                input.addEventListener('change', (e) => {
                    if (currentMediaObjectUrl) {
                        URL.revokeObjectURL(currentMediaObjectUrl); // Clean up previous object URL
                        currentMediaObjectUrl = null;
                    }
                    if (currentAudioPlayer) {
                        currentAudioPlayer.pause();
                        currentAudioPlayer = null;
                    }

                    if (e.target.files.length > 0) {
                        const file = e.target.files[0];
                        const fileName = file.name;
                        blocks[id].content = fileName; // Store full file name
                        
                        // Truncate for display, add full name as tooltip
                        const displayFileName = fileName.length > 25 ? fileName.substring(0, 25) + '...' : fileName;
                        titleElement.textContent = `File: ${displayFileName}`;
                        titleElement.title = fileName; // Tooltip with full name
                        blocks[id].title = titleElement.textContent; // Update block data with display name

                        currentMediaObjectUrl = URL.createObjectURL(file);

                        if (file.type.startsWith('audio/')) {
                            mediaIcon.classList.remove('hidden');
                            mediaIconPath.setAttribute('d', 'M14.752 11.168l-3.197-2.132A1 1 0 0010 9.87v4.263a1 1 0 001.555.832l3.197-2.132a1 1 0 000-1.664z'); // Play icon
                            
                            mediaIcon.onclick = (e) => {
                                e.stopPropagation(); // Prevent block click logic
                                if (!currentAudioPlayer) {
                                    currentAudioPlayer = new Audio(currentMediaObjectUrl);
                                    currentAudioPlayer.onended = () => {
                                        mediaIconPath.setAttribute('d', 'M14.752 11.168l-3.197-2.132A1 1 0 0010 9.87v4.263a1 1 0 001.555.832l3.197-2.132a1 1 0 000-1.664z'); // Reset to play icon
                                    };
                                }
                                if (currentAudioPlayer.paused) {
                                    currentAudioPlayer.play();
                                    mediaIconPath.setAttribute('d', 'M10 9h4V5h-4v4zm0 6h4v-4h-4v4zM4 4h16v16H4V4z'); // Pause icon (simple square)
                                } else {
                                    currentAudioPlayer.pause();
                                    mediaIconPath.setAttribute('d', 'M14.752 11.168l-3.197-2.132A1 1 0 0010 9.87v4.263a1 1 0 001.555.832l3.197-2.132a1 1 0 000-1.664z'); // Play icon
                                }
                            };
                        } else if (file.type.startsWith('video/')) {
                            mediaIcon.classList.remove('hidden');
                            mediaIconPath.setAttribute('d', 'M14.752 11.168l-3.197-2.132A1 1 0 0010 9.87v4.263a1 1 0 001.555.832l3.197-2.132a1 1 0 000-1.664z'); // Play icon
                            mediaIcon.onclick = (e) => {
                                e.stopPropagation(); // Prevent block click logic
                                showVideoModal(currentMediaObjectUrl);
                            };
                        } else {
                            mediaIcon.classList.add('hidden'); // Hide icon for non-media files
                            mediaIcon.onclick = null;
                        }

                    } else {
                        blocks[id].content = '';
                        titleElement.textContent = getDefaultTitle(type);
                        titleElement.title = ''; // Clear tooltip
                        blocks[id].title = getDefaultTitle(type);
                        mediaIcon.classList.add('hidden');
                        mediaIcon.onclick = null;
                    }
                });
                block.appendChild(input);
            } else if (type === 'json-list-box') {
                block.classList.add('bg-yellow-100', 'border-yellow-300');
                const textarea = document.createElement('textarea');
                textarea.classList.add('w-full', 'h-20', 'p-2', 'text-sm', 'rounded-md', 'border', 'border-yellow-200', 'focus:outline-none', 'focus:ring-2', 'focus:ring-yellow-400', 'resize-none', 'font-mono'); // Monospaced font for code
                textarea.placeholder = "Enter JSON or list items (e.g., ['item1', 'item2'] or { 'key': 'value' })...";
                textarea.addEventListener('input', () => {
                    blocks[id].content = textarea.value; // Update content in block data
                });
                block.appendChild(textarea);

                // Add AI button for JSON/List Box
                const aiButton = document.createElement('button');
                aiButton.classList.add('mt-2', 'px-3', 'py-1', 'bg-yellow-600', 'hover:bg-yellow-700', 'text-white', 'text-xs', 'rounded-md', 'font-medium', 'shadow-sm');
                aiButton.textContent = '✨ AI Data ✨';
                aiButton.addEventListener('click', (e) => {
                    e.stopPropagation(); // Prevent block drag/connection logic
                    activeLlmBlockId = id;
                    llmModalTitle.textContent = 'AI Data Assistant';
                    llmModalInputArea.value = blocks[id].content;
                    llmModalResponseArea.textContent = 'AI Response will appear here.';
                    llmModalApplyBtn.disabled = true;
                    showModal(llmModalContainer);
                });
                block.appendChild(aiButton);
            }

            // Add connector points (only left and right)
            const connectors = ['left', 'right'];
            connectors.forEach(side => {
                const connector = document.createElement('div');
                connector.classList.add('connector', side);
                connector.dataset.blockId = id;
                connector.dataset.side = side;
                block.appendChild(connector);

                connector.addEventListener('mousedown', (e) => {
                    e.stopPropagation(); // Prevent block drag when clicking connector
                    isDrawingConnection = true;
                    startConnector = { blockId: id, side: side, element: connector }; // Store element reference
                    
                    const startCoords = getConnectorAbsolutePosition(connector);
                    currentMouseX = startCoords.x; // Initialize currentMouseX/Y for temp line
                    currentMouseY = startCoords.y;

                    clearCanvas();
                    drawAllConnections();
                    // Draw initial temp line (will be updated in mousemove)
                    ctx.beginPath();
                    ctx.moveTo(startCoords.x, startCoords.y);
                    
                    // Draw temporary Bézier curve
                    const tempDx = Math.abs(startCoords.x - currentMouseX);
                    const tempCp1x = startCoords.x + tempDx * 0.5;
                    const tempCp1y = startCoords.y;
                    const tempCp2x = currentMouseX - tempDx * 0.5;
                    const tempCp2y = currentMouseY;
                    ctx.bezierCurveTo(tempCp1x, tempCp1y, tempCp2x, tempCp2y, currentMouseX, currentMouseY);

                    ctx.strokeStyle = '#3b82f6';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([]);
                    ctx.stroke();
                });

                connector.addEventListener('mouseup', (e) => {
                    e.stopPropagation(); // Prevent workflowArea mouseup from cancelling
                    if (isDrawingConnection && startConnector) {
                        const endBlockId = connector.dataset.blockId;
                        const endSide = connector.dataset.side;

                        // Only connect if it's a different block and not the same connector
                        if (startConnector.blockId !== endBlockId) { // Removed side check for now for simpler connections
                            connectBlocks(startConnector.blockId, startConnector.side, endBlockId, endSide, defaultConnectionType); // Use selected default type
                        }
                        isDrawingConnection = false;
                        startConnector = null;
                        drawAllConnections(); // Redraw all connections to clear temp line
                    }
                });
            });

            // Add right-click listener for context menu
            block.addEventListener('contextmenu', (e) => {
                e.preventDefault(); // Prevent default browser context menu
                showContextMenu(e.clientX, e.clientY, id);
            });

            return block;
        }

        // Helper to get connector absolute position relative to workflow area
        function getConnectorAbsolutePosition(connectorElement) {
            const connectorRect = connectorElement.getBoundingClientRect();
            const workflowRect = workflowArea.getBoundingClientRect();
            // Center of the connector
            const x = connectorRect.left + connectorRect.width / 2 - workflowRect.left;
            const y = connectorRect.top + connectorRect.height / 2 - workflowRect.top;
            return { x, y };
        }

        // --- Make Block Draggable within Workflow Area ---
        function makeBlockDraggable(blockElement, id) {
            let isDragging = false;
            let offsetX, offsetY;

            blockElement.addEventListener('mousedown', (e) => {
                // Only drag if not clicking on textarea, input, connector, media icon, or button
                if (e.target.tagName === 'TEXTAREA' || e.target.tagName === 'INPUT' || e.target.classList.contains('connector') || e.target.closest('.media-icon') || e.target.closest('button') || e.target.classList.contains('error-icon')) {
                    return; // Added error-icon to elements that prevent drag
                }
                isDragging = true;
                offsetX = e.clientX - blockElement.getBoundingClientRect().left;
                offsetY = e.clientY - blockElement.getBoundingClientRect().top;
                blockElement.style.cursor = 'grabbing';
                blockElement.style.zIndex = '20'; // Bring to front while dragging
            });

            workflowArea.addEventListener('mousemove', (e) => {
                if (isDragging) {
                    let newX = e.clientX - workflowArea.getBoundingClientRect().left - offsetX;
                    let newY = e.clientY - workflowArea.getBoundingClientRect().top - offsetY;

                    // Clamp to workflow area boundaries
                    newX = Math.max(0, Math.min(newX, workflowArea.offsetWidth - blockElement.offsetWidth));
                    newY = Math.max(0, Math.min(newY, workflowArea.offsetHeight - blockElement.offsetHeight));

                    blockElement.style.left = `${newX}px`;
                    blockElement.style.top = `${newY}px`;

                    blocks[id].x = newX;
                    blocks[id].y = newY;
                    // Update width/height in case the block resized (e.g. due to text content)
                    blocks[id].width = blockElement.offsetWidth;
                    blocks[id].height = blockElement.offsetHeight;

                    updateConnectionsForBlock(id);
                } else if (isDrawingConnection && startConnector) {
                    // Update temporary line end point
                    const workflowAreaRect = workflowArea.getBoundingClientRect();
                    currentMouseX = e.clientX - workflowAreaRect.left;
                    currentMouseY = e.clientY - workflowAreaRect.top;
                    
                    clearCanvas();
                    drawAllConnections(); // Redraw existing connections
                    
                    ctx.beginPath();
                    ctx.moveTo(getConnectorAbsolutePosition(startConnector.element).x, getConnectorAbsolutePosition(startConnector.element).y);
                    
                    // Draw temporary Bézier curve
                    const tempDx = Math.abs(getConnectorAbsolutePosition(startConnector.element).x - currentMouseX);
                    const tempCp1x = getConnectorAbsolutePosition(startConnector.element).x + tempDx * 0.5;
                    const tempCp1y = getConnectorAbsolutePosition(startConnector.element).y;
                    const tempCp2x = currentMouseX - tempDx * 0.5;
                    const tempCp2y = currentMouseY;
                    ctx.bezierCurveTo(tempCp1x, tempCp1y, tempCp2x, tempCp2y, currentMouseX, currentMouseY);

                    ctx.strokeStyle = '#3b82f6';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([]); // Solid for temp line
                    ctx.stroke();
                }
            });

            workflowArea.addEventListener('mouseup', (e) => {
                if (isDragging) {
                    isDragging = false;
                    blockElement.style.cursor = 'grab';
                    blockElement.style.zIndex = '10'; // Reset z-index
                    // Final update of dimensions after drag ends
                    blocks[id].width = blockElement.offsetWidth;
                    blocks[id].height = blockElement.offsetHeight;
                    updateConnectionsForBlock(id); // Ensure connections are updated one last time
                }
                // Connection drawing mouseup is handled by connector.mouseup or workflowArea.mouseup (for cancelling)
            });

            // Prevent text selection during drag
            blockElement.addEventListener('dragstart', (e) => e.preventDefault());
        }

        // --- Notification/Error Icon Functionality ---
        function toggleBlockError(blockId, showError, message = '') {
            const block = blocks[blockId];
            if (block) {
                const errorIconElement = block.element.querySelector('.error-icon');
                if (errorIconElement) {
                    if (showError) {
                        errorIconElement.classList.remove('hidden');
                        block.hasError = true;
                        block.errorMessage = message;
                    } else {
                        errorIconElement.classList.add('hidden');
                        block.hasError = false;
                        block.errorMessage = '';
                    }
                }
            }
        }

        // --- Context Menu Logic ---
        function showContextMenu(x, y, blockId) {
            currentContextMenuBlockId = blockId;
            contextMenu.style.left = `${x}px`;
            contextMenu.style.top = `${y}px`;
            contextMenu.classList.remove('hidden');

            // Connection options are no longer in context menu
        }

        // Hide context menu when clicking elsewhere
        document.addEventListener('click', (e) => {
            if (!contextMenu.contains(e.target) && !e.target.closest('.draggable-block')) {
                contextMenu.classList.add('hidden');
                currentContextMenuBlockId = null;
            }
        });

        contextMenu.addEventListener('click', (e) => {
            const action = e.target.dataset.action;
            if (!action || !currentContextMenuBlockId) return;

            contextMenu.classList.add('hidden');

            if (action === 'remove-connection') {
                removeConnectionsForBlock(currentContextMenuBlockId);
            } else if (action === 'delete') {
                deleteBlock(currentContextMenuBlockId);
            }
            currentContextMenuBlockId = null;
        });

        // --- Connection Logic ---
        function connectBlocks(fromId, fromSide, toId, toSide, type = 'solid') {
            // Prevent self-connection
            if (fromId === toId) {
                showMessageBox("Connection Error", "Cannot connect a block to itself.");
                return;
            }

            // Prevent duplicate connections (A->B and B->A are considered duplicates for simplicity)
            const exists = connections.some(conn =>
                (conn.fromBlock === fromId && conn.toBlock === toId) ||
                (conn.fromBlock === toId && conn.toBlock === fromId)
            );
            if (exists) {
                showMessageBox("Connection Error", "A connection between these two blocks already exists.");
                return;
            }

            const fromBlock = blocks[fromId];
            const toBlock = blocks[toId];

            if (!fromBlock || !toBlock) {
                console.error("One or both blocks not found for connection.");
                return;
            }

            const connection = {
                fromBlock: fromId,
                fromSide: fromSide,
                toBlock: toId,
                toSide: toSide,
                type: type // 'solid', 'dashed', 'arrow' - though currently only solid is used
            };
            connections.push(connection);

            drawAllConnections(); // Redraw all connections including the new one
        }

        function updateConnectionsForBlock(blockId) {
            drawAllConnections(); // Simplest way is to redraw all, can optimize later if needed
        }

        function removeConnectionsForBlock(blockId) {
            connections = connections.filter(conn => {
                return conn.fromBlock !== blockId && conn.toBlock !== blockId;
            });
            drawAllConnections(); // Redraw after removal
        }

        // --- Delete Block Logic ---
        function deleteBlock(id) {
            const blockElement = blocks[id]?.element;
            if (blockElement) {
                blockElement.remove();
                delete blocks[id];
                removeConnectionsForBlock(id); // Remove any associated connections
                updatePlaceholderVisibility();
            }
        }

        // Initial check to remove placeholder text if blocks exist
        function updatePlaceholderVisibility() {
            const placeholder = workflowArea.querySelector('p.text-center');
            if (Object.keys(blocks).length > 0) {
                if (placeholder) placeholder.classList.add('hidden');
            } else {
                if (placeholder) placeholder.classList.remove('hidden');
            }
        }

        // --- Display Connections Popup ---
        displayConnectionsBtn.addEventListener('click', () => {
            if (connections.length === 0) {
                showMessageBox("Connections", "No connections have been established yet.");
                return;
            }

            let connectionsSummary = "Current Connections:\n\n";
            connections.forEach(conn => {
                const fromBlockTitle = blocks[conn.fromBlock] ? blocks[conn.fromBlock].title : `Block ${conn.fromBlock}`;
                const toBlockTitle = blocks[conn.toBlock] ? blocks[conn.toBlock].title : `Block ${conn.toBlock}`;
                connectionsSummary += `- "${fromBlockTitle}" (ID: ${conn.fromBlock}, Side: ${conn.fromSide}) -> "${toBlockTitle}" (ID: ${conn.toBlock}, Side: ${conn.toSide}) [Type: ${conn.type}]\n`;
            });
            showMessageBox("Workflow Connections", connectionsSummary);
        });

        // --- Save as Image Functionality ---
        saveImageBtn.addEventListener('click', () => {
            // Temporarily hide canvas to capture only HTML elements
            connectionCanvas.style.display = 'none';

            html2canvas(workflowArea, {
                useCORS: true,
                scale: 2,
                backgroundColor: '#ffffff'
            }).then(htmlCanvas => {
                // Re-enable canvas
                connectionCanvas.style.display = 'block';

                // Create a new canvas to merge HTML and SVG/Canvas
                const finalCanvas = document.createElement('canvas');
                finalCanvas.width = htmlCanvas.width;
                finalCanvas.height = htmlCanvas.height;
                const finalCtx = finalCanvas.getContext('2d');

                // Draw HTML content
                finalCtx.drawImage(htmlCanvas, 0, 0);

                // Draw connections from our canvas
                finalCtx.drawImage(connectionCanvas, 0, 0, connectionCanvas.width, connectionCanvas.height);


                const image = finalCanvas.toDataURL('image/png');
                const link = document.createElement('a');
                link.href = image;
                link.download = 'workflow-automation.png';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
            }).catch(error => {
                console.error('Error saving workflow as image:', error);
                showMessageBox("Save Error", "Could not save image. Please try again.");
                connectionCanvas.style.display = 'block'; // Ensure canvas is visible even on error
            });
        });

        // --- Start Automation Process ---
        startAutomationBtn.addEventListener('click', async () => {
            let automationSummary = `Workflow Title: ${workflowTitle}\n\n`; // Include workflow title
            let hasContent = false;
            let validationFailed = false;

            // Validate all relevant blocks for content
            for (const id in blocks) {
                const block = blocks[id];
                if (block.type === 'text-box' || block.type === 'json-list-box') {
                    const content = block.content.trim();
                    if (!content) {
                        toggleBlockError(id, true, `Block "${block.title}" cannot be empty. Please add content.`);
                        validationFailed = true;
                        // Do not break here, so all errors can be marked
                    } else {
                        toggleBlockError(id, false); // Clear error if content is present
                    }
                }
            }

            if (validationFailed) {
                showMessageBox("Validation Error", "Please fix the errors in the blocks before starting automation.");
                return; // Stop automation if validation failed
            }

            // Generate summary for blocks
            const blocksData = [];
            for (const id in blocks) {
                const block = blocks[id];
                const blockInfo = {
                    id: id,
                    type: block.type,
                    title: block.title,
                    content: block.content,
                    settings: blocks[id].settings // Include block-specific settings
                };
                blocksData.push(blockInfo);

                automationSummary += `Block ID: ${id}\n`;
                automationSummary += `Type: ${block.type}\n`;
                automationSummary += `Title: ${block.title}\n`;
                automationSummary += `Content: "${block.content}"\n`;
                automationSummary += `Settings: ${JSON.stringify(block.settings, null, 2)}\n\n`; // Add settings to summary
                if (block.content) hasContent = true;
            }

            // Prepare connections data for submission
            const connectionsData = connections.map(conn => ({
                fromBlock: conn.fromBlock,
                fromSide: conn.fromSide,
                toBlock: conn.toBlock,
                toSide: conn.toSide,
                type: conn.type
            }));

            // Add connections to summary
            if (connectionsData.length > 0) {
                automationSummary += "Connections:\n";
                connectionsData.forEach(conn => {
                    const fromBlockTitle = blocks[conn.fromBlock] ? blocks[conn.fromBlock].title : 'Unknown Block';
                    const toBlockTitle = blocks[conn.toBlock] ? blocks[conn.toBlock].title : 'Unknown Block';
                    automationSummary += `- From: "${fromBlockTitle}" (ID: ${conn.fromBlock}, Side: ${conn.fromSide}) -> "${toBlockTitle}" (ID: ${conn.toBlock}, Side: ${conn.toSide}) [Type: ${conn.type}]\n`;
                });
                automationSummary += `\n`;
            } else {
                automationSummary += "No connections established.\n\n";
            }

            if (Object.keys(blocks).length === 0) {
                showMessageBox("Automation Status", "No blocks in the workflow to automate.");
                return;
            } else if (!hasContent && Object.keys(blocks).some(id => blocks[id].type !== 'file-upload')) {
                // Only show this warning if there are non-file-upload blocks without content
                showMessageBox("Automation Status", "No content found in any text/JSON blocks. Please add text or select files.");
                return;
            }
            
            // Simulate progress bar
            progressBarWrapper.classList.remove('hidden');
            progressBarFill.style.width = '0%';
            let progress = 0;
            const interval = setInterval(() => {
                progress += 10;
                progressBarFill.style.width = `${progress}%`;
                if (progress >= 100) {
                    clearInterval(interval);
                    
                    // After progress bar completes, attempt to send data
                    sendWorkflowData(blocksData, connectionsData, automationSummary);
                }
            }, 100); // Update every 100ms
        });

        // Function to send workflow data (SIMULATED)
        async function sendWorkflowData(blocksData, connectionsData, automationSummary) {
            const payload = {
                workflowTitle: workflowTitle, // Include workflow title in payload
                blocks: blocksData,
                connections: connectionsData
            };

            console.log('Simulating workflow submission with payload:', payload);

            // Simulate a network request with a delay
            setTimeout(() => {
                const success = Math.random() > 0.2; // 80% chance of success

                if (success) {
                    const simulatedResponse = { status: 'success', message: 'Workflow processed successfully!', receivedData: payload };
                    showMessageBox("Automation Process Complete!", `Workflow submitted successfully!\n\nSimulated Server Response: ${JSON.stringify(simulatedResponse, null, 2)}\n\n${automationSummary}`);
                } else {
                    const simulatedError = { status: 'error', message: 'Simulated network error or server issue.' };
                    showMessageBox("Submission Failed (Simulated)", `Failed to submit workflow. Simulated error: ${simulatedError.message}\n\n${automationSummary}`);
                }
                progressBarWrapper.classList.add('hidden'); // Hide progress bar regardless of success/failure
            }, 1500); // Simulate a 1.5 second network delay
        }

        // Initial call to hide placeholder if blocks are somehow present on load (unlikely for new app)
        updatePlaceholderVisibility();
    </script>
</body>
</html>
